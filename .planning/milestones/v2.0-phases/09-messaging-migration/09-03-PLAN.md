---
phase: 09-messaging-migration
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - services/analytics-consumer/internal/handler/clickevent.go
  - services/analytics-consumer/internal/svc/servicecontext.go
  - services/analytics-consumer/consumer.go
  - services/analytics-rpc/model/clicksmodel.go
  - services/analytics-rpc/model/clicksmodel_gen.go
autonomous: true

must_haves:
  truths:
    - "Consumer processes ClickEvent from Kafka and inserts enriched click record into PostgreSQL"
    - "Click events are enriched with GeoIP country code, device type, and traffic source"
    - "Duplicate click events do not inflate analytics counts"
    - "Consumer returns nil for all errors (offset always committed, no infinite retry)"
    - "GeoIP database absence does not crash the consumer (falls back to Unknown)"
  artifacts:
    - path: "services/analytics-consumer/internal/handler/clickevent.go"
      provides: "ClickEvent consumer handler with enrichment logic"
      contains: "enrichGeoIP"
    - path: "services/analytics-rpc/model/clicksmodel.go"
      provides: "ClicksModel with InsertEnriched method for enriched click data"
      contains: "InsertEnriched"
  key_links:
    - from: "services/analytics-consumer/internal/handler/clickevent.go"
      to: "services/analytics-rpc/model"
      via: "svcCtx.ClickModel.InsertEnriched()"
      pattern: "ClickModel\\.InsertEnriched"
    - from: "services/analytics-consumer/consumer.go"
      to: "services/analytics-consumer/internal/handler/clickevent.go"
      via: "kq.WithHandle(handler.Consume)"
      pattern: "WithHandle"
---

<objective>
Implement the analytics-consumer ClickEvent handler with GeoIP country lookup, user agent parsing (device type/browser), and referer traffic source extraction. Insert enriched click records into PostgreSQL with idempotent handling.

Purpose: Complete the analytics event pipeline. Consumer enriches raw click events with geographic, device, and traffic data, then persists to clicks table for analytics queries.

Output: Fully functional analytics consumer that processes Kafka events, enriches with geo/device/referer data, and inserts into PostgreSQL.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-messaging-migration/09-RESEARCH.md
@.planning/phases/09-messaging-migration/09-01-SUMMARY.md
@common/events/events.go
@services/analytics-rpc/model/clicksmodel.go
@services/analytics-rpc/model/clicksmodel_gen.go
@services/analytics-consumer/consumer.go
@services/analytics-consumer/internal/svc/servicecontext.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update clicks model for enriched inserts and build consumer handler</name>
  <files>
    services/analytics-rpc/model/clicksmodel.go
    services/analytics-consumer/internal/handler/clickevent.go
  </files>
  <action>
    1. **Update `services/analytics-rpc/model/clicksmodel.go`**:
       The generated `Insert` method only handles `id`, `short_code`, `clicked_at` (the original 3 columns). Add a custom `InsertEnriched` method for the enriched columns. Also update the `ClicksModel` interface:
       ```go
       type ClicksModel interface {
         clicksModel
         withSession(session sqlx.Session) ClicksModel
         CountByShortCode(ctx context.Context, shortCode string) (int64, error)
         InsertEnriched(ctx context.Context, id, shortCode string, clickedAt time.Time, countryCode, deviceType, trafficSource string) error
       }
       ```

       Implement `InsertEnriched`:
       ```go
       func (m *customClicksModel) InsertEnriched(ctx context.Context, id, shortCode string, clickedAt time.Time, countryCode, deviceType, trafficSource string) error {
         query := fmt.Sprintf(
           "INSERT INTO %s (id, short_code, clicked_at, country_code, device_type, traffic_source) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT DO NOTHING",
           m.table,
         )
         _, err := m.conn.ExecCtx(ctx, query, id, shortCode, clickedAt, countryCode, deviceType, trafficSource)
         return err
       }
       ```
       **Important:** `ON CONFLICT DO NOTHING` provides idempotency. If the same click (by UUID) is processed twice, the second insert is silently ignored.

    2. **Create `services/analytics-consumer/internal/handler/clickevent.go`**:
       This is the core handler with all enrichment logic in one file:

       ```go
       package handler

       import (
         "context"
         "encoding/json"
         "net"
         "net/url"
         "strings"
         "time"

         "go-shortener/common/events"
         "go-shortener/services/analytics-consumer/internal/svc"

         "github.com/google/uuid"
         "github.com/mileusna/useragent"
         "github.com/oschwald/geoip2-golang"
         "github.com/zeromicro/go-zero/core/logx"
       )

       type ClickEventHandler struct {
         svcCtx      *svc.ServiceContext
         geoipReader *geoip2.Reader
       }

       func NewClickEventHandler(svcCtx *svc.ServiceContext) *ClickEventHandler {
         h := &ClickEventHandler{svcCtx: svcCtx}

         // GeoIP: optional, falls back to "Unknown" if file not found
         if svcCtx.Config.GeoIPDbPath != "" {
           reader, err := geoip2.Open(svcCtx.Config.GeoIPDbPath)
           if err != nil {
             logx.Errorw("geoip database not available, using fallback",
               logx.Field("path", svcCtx.Config.GeoIPDbPath),
               logx.Field("error", err.Error()),
             )
           } else {
             h.geoipReader = reader
           }
         }

         return h
       }

       func (h *ClickEventHandler) Consume(ctx context.Context, key, val string) error {
         var event events.ClickEvent
         if err := json.Unmarshal([]byte(val), &event); err != nil {
           logx.Errorw("invalid click event, skipping", logx.Field("error", err.Error()))
           return nil // Don't retry malformed messages
         }

         logx.Infow("processing click event",
           logx.Field("short_code", event.ShortCode),
           logx.Field("ip", event.IP),
         )

         // Enrich
         countryCode := h.enrichGeoIP(event.IP)
         deviceType := h.enrichDeviceType(event.UserAgent)
         trafficSource := h.enrichReferer(event.Referer)

         // Generate UUIDv7 for click record
         clickID, _ := uuid.NewV7()
         clickedAt := time.Unix(event.Timestamp, 0)

         // Insert with idempotency (ON CONFLICT DO NOTHING)
         if err := h.svcCtx.ClickModel.InsertEnriched(
           ctx, clickID.String(), event.ShortCode, clickedAt,
           countryCode, deviceType, trafficSource,
         ); err != nil {
           logx.Errorw("failed to insert click",
             logx.Field("short_code", event.ShortCode),
             logx.Field("error", err.Error()),
           )
         }

         return nil // Always commit offset
       }

       func (h *ClickEventHandler) enrichGeoIP(ipStr string) string {
         if h.geoipReader == nil {
           return "Unknown"
         }

         // Strip port if present (e.g., "192.168.1.1:54321" -> "192.168.1.1")
         host, _, err := net.SplitHostPort(ipStr)
         if err != nil {
           host = ipStr // No port, use as-is
         }

         ip := net.ParseIP(host)
         if ip == nil {
           return "Unknown"
         }

         record, err := h.geoipReader.Country(ip)
         if err != nil {
           logx.Errorw("geoip lookup failed", logx.Field("error", err.Error()))
           return "Unknown"
         }

         if record.Country.IsoCode == "" {
           return "Unknown"
         }

         return record.Country.IsoCode
       }

       func (h *ClickEventHandler) enrichDeviceType(uaStr string) string {
         if uaStr == "" {
           return "unknown"
         }

         ua := useragent.Parse(uaStr)
         switch {
         case ua.Mobile:
           return "mobile"
         case ua.Tablet:
           return "tablet"
         case ua.Desktop:
           return "desktop"
         case ua.Bot:
           return "bot"
         default:
           return "unknown"
         }
       }

       func (h *ClickEventHandler) enrichReferer(referer string) string {
         if referer == "" {
           return "direct"
         }

         u, err := url.Parse(referer)
         if err != nil || u.Host == "" {
           return "direct"
         }

         domain := strings.TrimPrefix(u.Host, "www.")

         switch {
         case strings.Contains(domain, "google.com"):
           return "google"
         case strings.Contains(domain, "facebook.com"):
           return "facebook"
         case strings.Contains(domain, "twitter.com"), strings.Contains(domain, "x.com"):
           return "twitter"
         case strings.Contains(domain, "linkedin.com"):
           return "linkedin"
         case strings.Contains(domain, "reddit.com"):
           return "reddit"
         default:
           return domain
         }
       }

       func (h *ClickEventHandler) Close() {
         if h.geoipReader != nil {
           h.geoipReader.Close()
         }
       }
       ```

       **Design decisions:**
       - GeoIP reader is optional (nil-safe). Falls back to "Unknown" if MMDB file not found.
       - `enrichGeoIP` strips port from RemoteAddr before parsing IP.
       - `enrichDeviceType` returns simple categories: mobile, tablet, desktop, bot, unknown.
       - `enrichReferer` classifies known social/search sources, falls back to raw domain.
       - `Consume` always returns nil to commit Kafka offset (no infinite retry).
       - `ON CONFLICT DO NOTHING` in InsertEnriched handles duplicate events.
       - UUIDv7 for click record IDs (time-ordered, matches urls table pattern).
  </action>
  <verify>
    - `go build ./services/analytics-consumer/...` compiles without errors
    - `go build ./services/analytics-rpc/...` compiles without errors (model interface updated)
    - `go vet ./...` passes
  </verify>
  <done>ClickEvent handler enriches with geo/device/referer, inserts enriched click with idempotency</done>
</task>

<task type="auto">
  <name>Task 2: Wire consumer handler into main entry point and update ServiceContext</name>
  <files>
    services/analytics-consumer/consumer.go
    services/analytics-consumer/internal/svc/servicecontext.go
  </files>
  <action>
    1. **Update `services/analytics-consumer/internal/svc/servicecontext.go`** if needed:
       The ServiceContext from 09-01 already has Config and ClickModel. Verify no changes needed. The GeoIP reader lives in the handler, not in ServiceContext (handler-scoped lifecycle for proper Close()).

    2. **Update `services/analytics-consumer/consumer.go`**:
       Replace the placeholder handler with the real ClickEventHandler:
       ```go
       package main

       import (
         "flag"
         "go-shortener/services/analytics-consumer/internal/config"
         "go-shortener/services/analytics-consumer/internal/handler"
         "go-shortener/services/analytics-consumer/internal/svc"

         "github.com/zeromicro/go-queue/kq"
         "github.com/zeromicro/go-zero/core/conf"
         "github.com/zeromicro/go-zero/core/logx"
         "github.com/zeromicro/go-zero/core/service"
       )

       var configFile = flag.String("f", "etc/consumer.yaml", "config file")

       func main() {
         flag.Parse()

         var c config.Config
         conf.MustLoad(*configFile, &c)

         svcCtx := svc.NewServiceContext(c)
         clickHandler := handler.NewClickEventHandler(svcCtx)
         defer clickHandler.Close()

         consumer := kq.MustNewQueue(c.KqConf, kq.WithHandle(clickHandler.Consume))

         serviceGroup := service.NewServiceGroup()
         defer serviceGroup.Stop()

         serviceGroup.Add(consumer)

         logx.Info("Starting analytics consumer...")
         serviceGroup.Start()
       }
       ```

       **Key points:**
       - `clickHandler.Close()` deferred to properly close GeoIP reader on shutdown
       - `kq.WithHandle(clickHandler.Consume)` wires the real handler
       - ServiceGroup provides graceful shutdown on SIGINT/SIGTERM

    3. **Run `go mod tidy`** to ensure all imports resolve correctly.
  </action>
  <verify>
    - `go build ./services/analytics-consumer/...` compiles without errors
    - `go build ./...` compiles (no regressions)
    - Start full stack: postgres, kafka, analytics-rpc, analytics-consumer, url-api
    - Create a short URL: `curl -X POST http://localhost:8080/api/v1/urls -d '{"original_url":"https://example.com"}'`
    - Visit short URL: `curl -i http://localhost:8080/:code` (302 redirect)
    - Check consumer logs for enriched click processing
    - Check analytics: `curl http://localhost:8080/api/v1/links/:code` shows `total_clicks: 1`
    - Visit same URL again and verify count increments to 2
  </verify>
  <done>Analytics consumer fully wired: processes Kafka events, enriches with geo/device/referer, persists to PostgreSQL, click counts visible via zRPC</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. Consumer processes ClickEvent and enriches with country_code, device_type, traffic_source
3. Click record appears in clicks table with enrichment columns populated
4. Duplicate events (same UUID) do not create duplicate rows (ON CONFLICT DO NOTHING)
5. Consumer continues processing when GeoIP database is absent (falls back to "Unknown")
6. End-to-end: shorten URL -> redirect -> Kafka event -> consumer enrichment -> click in DB -> GetClickCount via zRPC returns correct count
</verification>

<success_criteria>
- ClickEvent consumer parses JSON, enriches with GeoIP/UA/referer, inserts into PostgreSQL
- GeoIP: country ISO code (e.g., "US") or "Unknown" if unavailable
- Device type: mobile/tablet/desktop/bot/unknown
- Traffic source: google/facebook/twitter/linkedin/reddit/direct/raw-domain
- Idempotent inserts via ON CONFLICT DO NOTHING
- Consumer always returns nil (offset committed, no infinite retry)
- Full pipeline works: redirect -> Kafka -> consumer -> DB -> zRPC query
</success_criteria>

<output>
After completion, create `.planning/phases/09-messaging-migration/09-03-SUMMARY.md`
</output>
