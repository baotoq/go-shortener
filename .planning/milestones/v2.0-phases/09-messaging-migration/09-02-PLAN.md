---
phase: 09-messaging-migration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - services/url-api/internal/config/config.go
  - services/url-api/internal/svc/servicecontext.go
  - services/url-api/internal/logic/redirect/redirectlogic.go
  - services/url-api/internal/handler/redirect/redirecthandler.go
  - services/url-api/internal/logic/links/getlinkdetaillogic.go
  - services/url-api/etc/url.yaml
autonomous: true

must_haves:
  truths:
    - "Redirect handler publishes ClickEvent to Kafka without blocking the redirect response"
    - "User is redirected before Kafka publish completes (fire-and-forget preserved)"
    - "GetLinkDetail calls Analytics zRPC to get click count (not local click_count column)"
    - "GetLinkDetail falls back to 0 clicks if Analytics RPC is unreachable"
  artifacts:
    - path: "services/url-api/internal/svc/servicecontext.go"
      provides: "ServiceContext with KqPusher and AnalyticsRpc client"
      contains: "KqPusher"
    - path: "services/url-api/internal/logic/redirect/redirectlogic.go"
      provides: "Redirect logic publishing ClickEvent via Kafka"
      contains: "threading.GoSafe"
    - path: "services/url-api/internal/logic/links/getlinkdetaillogic.go"
      provides: "GetLinkDetail calling Analytics zRPC"
      contains: "AnalyticsRpc"
    - path: "services/url-api/etc/url.yaml"
      provides: "Kafka pusher and Analytics RPC config"
      contains: "KqPusherConf"
  key_links:
    - from: "services/url-api/internal/logic/redirect/redirectlogic.go"
      to: "services/url-api/internal/svc/servicecontext.go"
      via: "l.svcCtx.KqPusher.Push()"
      pattern: "KqPusher\\.Push"
    - from: "services/url-api/internal/handler/redirect/redirecthandler.go"
      to: "services/url-api/internal/logic/redirect/redirectlogic.go"
      via: "passing *http.Request for IP/UA/Referer extraction"
      pattern: "NewRedirectLogic.*r \\*http\\.Request"
    - from: "services/url-api/internal/logic/links/getlinkdetaillogic.go"
      to: "services/analytics-rpc/analyticsclient"
      via: "l.svcCtx.AnalyticsRpc.GetClickCount()"
      pattern: "AnalyticsRpc\\.GetClickCount"
---

<objective>
Wire URL Service to publish ClickEvent to Kafka on redirect (fire-and-forget via threading.GoSafe) and call Analytics zRPC for GetLinkDetail click counts.

Purpose: Replace the in-process click count increment with Kafka event publishing for reliable async analytics, and use zRPC client for cross-service click count queries.

Output: URL Service publishes events to Kafka on redirect and calls Analytics RPC for link detail enrichment.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-messaging-migration/09-RESEARCH.md
@.planning/phases/09-messaging-migration/09-01-SUMMARY.md
@services/url-api/internal/config/config.go
@services/url-api/internal/svc/servicecontext.go
@services/url-api/internal/logic/redirect/redirectlogic.go
@services/url-api/internal/handler/redirect/redirecthandler.go
@services/url-api/internal/logic/links/getlinkdetaillogic.go
@services/url-api/etc/url.yaml
@common/events/events.go
@services/analytics-rpc/analyticsclient/analytics.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Kafka publisher and zRPC client to URL Service config/svc</name>
  <files>
    services/url-api/internal/config/config.go
    services/url-api/internal/svc/servicecontext.go
    services/url-api/etc/url.yaml
  </files>
  <action>
    1. **Update `services/url-api/internal/config/config.go`**:
       Add `KqPusherConf` (struct with Brokers + Topic) and `AnalyticsRpc` (zrpc.RpcClientConf) fields:
       ```go
       package config

       import (
         "github.com/zeromicro/go-zero/rest"
         "github.com/zeromicro/go-zero/zrpc"
       )

       type Config struct {
         rest.RestConf
         BaseUrl    string
         DataSource string
         KqPusherConf struct {
           Brokers []string
           Topic   string
         }
         AnalyticsRpc zrpc.RpcClientConf
       }
       ```

    2. **Update `services/url-api/internal/svc/servicecontext.go`**:
       Add `KqPusher *kq.Pusher` and `AnalyticsRpc analyticsclient.Analytics`:
       ```go
       package svc

       import (
         "go-shortener/services/url-api/internal/config"
         "go-shortener/services/url-api/model"
         "go-shortener/services/analytics-rpc/analyticsclient"
         "github.com/zeromicro/go-zero/core/stores/sqlx"
         "github.com/zeromicro/go-zero/zrpc"
         "github.com/zeromicro/go-queue/kq"
         _ "github.com/lib/pq"
       )

       type ServiceContext struct {
         Config       config.Config
         UrlModel     model.UrlsModel
         KqPusher     *kq.Pusher
         AnalyticsRpc analyticsclient.Analytics
       }

       func NewServiceContext(c config.Config) *ServiceContext {
         conn := sqlx.NewSqlConn("postgres", c.DataSource)
         return &ServiceContext{
           Config:       c,
           UrlModel:     model.NewUrlsModel(conn),
           KqPusher:     kq.NewPusher(c.KqPusherConf.Brokers, c.KqPusherConf.Topic),
           AnalyticsRpc: analyticsclient.NewAnalytics(zrpc.MustNewClient(c.AnalyticsRpc)),
         }
       }
       ```

    3. **Update `services/url-api/etc/url.yaml`**:
       Add Kafka pusher and Analytics RPC config:
       ```yaml
       KqPusherConf:
         Brokers:
           - 127.0.0.1:9092
         Topic: click-events

       AnalyticsRpc:
         Target: 127.0.0.1:8081
         NonBlock: true
         Timeout: 2000
       ```
       `NonBlock: true` prevents URL Service from blocking on startup if Analytics RPC is not yet available.
  </action>
  <verify>
    - `go build ./services/url-api/...` compiles without errors
    - `go vet ./services/url-api/...` passes
  </verify>
  <done>URL Service config has KqPusherConf and AnalyticsRpc, ServiceContext initializes both clients</done>
</task>

<task type="auto">
  <name>Task 2: Wire redirect to publish ClickEvent and GetLinkDetail to call zRPC</name>
  <files>
    services/url-api/internal/logic/redirect/redirectlogic.go
    services/url-api/internal/handler/redirect/redirecthandler.go
    services/url-api/internal/logic/links/getlinkdetaillogic.go
  </files>
  <action>
    1. **Update `services/url-api/internal/handler/redirect/redirecthandler.go`**:
       The redirect handler must pass the `*http.Request` to the logic layer so it can extract IP, UserAgent, and Referer for the ClickEvent. Modify `NewRedirectLogic` call to pass `r`:
       ```go
       l := redirect.NewRedirectLogic(r.Context(), svcCtx, r)
       ```
       The handler already does the HTTP 302 redirect correctly.

    2. **Update `services/url-api/internal/logic/redirect/redirectlogic.go`**:
       - Add `r *http.Request` field to `RedirectLogic` struct
       - Update `NewRedirectLogic` to accept `r *http.Request` parameter
       - Replace the goroutine `go func() { IncrementClickCount }` with `threading.GoSafe` publishing to Kafka:
       ```go
       func (l *RedirectLogic) Redirect(req *types.RedirectRequest) (string, error) {
         // 1. Look up URL (unchanged)
         url, err := l.svcCtx.UrlModel.FindOneByShortCode(l.ctx, req.Code)
         if err != nil { /* existing error handling */ }

         // 2. Fire-and-forget: publish ClickEvent to Kafka
         threading.GoSafe(func() {
           event := events.ClickEvent{
             ShortCode: req.Code,
             Timestamp: time.Now().Unix(),
             IP:        l.r.RemoteAddr,
             UserAgent: l.r.UserAgent(),
             Referer:   l.r.Referer(),
           }
           data, err := json.Marshal(event)
           if err != nil {
             logx.Errorw("failed to marshal click event", logx.Field("error", err.Error()))
             return
           }
           if err := l.svcCtx.KqPusher.Push(string(data)); err != nil {
             logx.Errorw("failed to publish click event",
               logx.Field("code", req.Code),
               logx.Field("error", err.Error()),
             )
           }
         })

         // 3. Return immediately (user never waits)
         return url.OriginalUrl, nil
       }
       ```
       **Key changes:**
       - Use `threading.GoSafe` instead of raw `go func()` for panic recovery
       - Publish JSON-serialized ClickEvent to Kafka instead of incrementing click_count
       - Extract IP from `r.RemoteAddr`, UserAgent from `r.UserAgent()`, Referer from `r.Referer()`
       - Remove the `IncrementClickCount` call entirely (analytics pipeline handles counting now)

    3. **Update `services/url-api/internal/logic/links/getlinkdetaillogic.go`**:
       Replace local `url.ClickCount` with zRPC call to Analytics Service:
       ```go
       func (l *GetLinkDetailLogic) GetLinkDetail(req *types.LinkDetailRequest) (resp *types.LinkDetailResponse, err error) {
         // 1. Find URL by short code (unchanged)
         url, findErr := l.svcCtx.UrlModel.FindOneByShortCode(l.ctx, req.Code)
         if findErr != nil { /* existing error handling */ }

         // 2. Call Analytics RPC for click count (with fallback)
         var totalClicks int64
         analyticsResp, rpcErr := l.svcCtx.AnalyticsRpc.GetClickCount(l.ctx,
           &analyticsclient.GetClickCountRequest{ShortCode: req.Code})
         if rpcErr != nil {
           logx.WithContext(l.ctx).Errorw("analytics rpc failed, using fallback",
             logx.Field("code", req.Code),
             logx.Field("error", rpcErr.Error()),
           )
           totalClicks = 0 // Fallback: return 0 if analytics unavailable
         } else {
           totalClicks = analyticsResp.TotalClicks
         }

         return &types.LinkDetailResponse{
           ShortCode:   url.ShortCode,
           OriginalUrl: url.OriginalUrl,
           CreatedAt:   url.CreatedAt.Unix(),
           TotalClicks: totalClicks,
         }, nil
       }
       ```
       **Key change:** No longer reads `url.ClickCount` from urls table. Instead calls Analytics zRPC with graceful fallback.

    4. **Import additions needed:**
       - redirectlogic.go: `"encoding/json"`, `"time"`, `"net/http"`, `"go-shortener/common/events"`, `"github.com/zeromicro/go-zero/core/threading"`
       - getlinkdetaillogic.go: `"go-shortener/services/analytics-rpc/analyticsclient"`
  </action>
  <verify>
    - `go build ./services/url-api/...` compiles without errors
    - `go vet ./services/url-api/...` passes
    - Start services (postgres + kafka + analytics-rpc + url-api)
    - `curl -i http://localhost:8080/:code` returns 302 redirect
    - Kafka consumer logs show the ClickEvent in console (from 09-01 placeholder)
    - `curl http://localhost:8080/api/v1/links/:code` returns link detail with total_clicks from zRPC
  </verify>
  <done>Redirect publishes ClickEvent to Kafka via threading.GoSafe, GetLinkDetail calls Analytics zRPC with fallback</done>
</task>

</tasks>

<verification>
1. `go build ./services/url-api/...` compiles
2. Redirect handler publishes ClickEvent to Kafka (visible in consumer logs)
3. Redirect response time is not affected by Kafka publishing
4. GetLinkDetail returns click count from Analytics zRPC
5. GetLinkDetail returns 0 clicks gracefully when Analytics RPC is down
</verification>

<success_criteria>
- URL Service publishes ClickEvent to Kafka after every redirect (fire-and-forget)
- threading.GoSafe used for panic-safe async publishing
- ClickEvent includes short_code, timestamp, IP, user_agent, referer
- Analytics zRPC client injected via ServiceContext with NonBlock and Timeout
- GetLinkDetail calls GetClickCount via zRPC with graceful fallback to 0
- URL yaml has KqPusherConf and AnalyticsRpc configuration
</success_criteria>

<output>
After completion, create `.planning/phases/09-messaging-migration/09-02-SUMMARY.md`
</output>
