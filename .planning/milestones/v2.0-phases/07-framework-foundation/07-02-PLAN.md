---
phase: 07-framework-foundation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - services/url-api/url.api
  - services/url-api/url.go
  - services/url-api/etc/url-api.yaml
  - services/url-api/internal/config/config.go
  - services/url-api/internal/handler/
  - services/url-api/internal/logic/
  - services/url-api/internal/svc/servicecontext.go
  - services/url-api/internal/types/types.go
  - Makefile
autonomous: true

must_haves:
  truths:
    - "URL Service .api spec defines all routes: POST /api/v1/urls, GET /:code, GET /api/v1/links, GET /api/v1/links/:code, DELETE /api/v1/links/:code"
    - "goctl generates handlers, routes, types, and logic stubs from .api without errors"
    - "Request validation rejects invalid input via .api tag rules (range, options, default)"
    - "Error responses use RFC 7807 Problem Details format via custom httpx.SetErrorHandler"
    - "URL Service starts on port 8080 and responds to all defined routes with stub data"
    - "go-zero built-in request logging is enabled (method, path, status, latency)"
  artifacts:
    - path: "services/url-api/url.api"
      provides: "API specification with types, validation tags, and route groups"
      contains: "syntax = \"v1\""
    - path: "services/url-api/url.go"
      provides: "Main entry point with custom error handler and server startup"
      contains: "httpx.SetErrorHandler"
    - path: "services/url-api/etc/url-api.yaml"
      provides: "YAML configuration for URL service"
      contains: "Name: url-api"
    - path: "services/url-api/internal/config/config.go"
      provides: "Config struct with embedded rest.RestConf"
      contains: "rest.RestConf"
    - path: "services/url-api/internal/svc/servicecontext.go"
      provides: "ServiceContext with Config only (stub for Phase 7)"
      contains: "ServiceContext"
    - path: "services/url-api/internal/handler/"
      provides: "Generated HTTP handlers for all route groups"
    - path: "services/url-api/internal/logic/"
      provides: "Logic stubs returning TODO/stub responses"
    - path: "services/url-api/internal/types/types.go"
      provides: "Generated request/response types with validation tags"
  key_links:
    - from: "services/url-api/url.go"
      to: "services/url-api/internal/handler/"
      via: "handler.RegisterHandlers(server, ctx)"
      pattern: "handler\\.RegisterHandlers"
    - from: "services/url-api/url.go"
      to: "services/url-api/internal/svc/servicecontext.go"
      via: "svc.NewServiceContext(c)"
      pattern: "svc\\.NewServiceContext"
    - from: "services/url-api/url.go"
      to: "pkg/problemdetails"
      via: "httpx.SetErrorHandler"
      pattern: "problemdetails"
    - from: "services/url-api/internal/handler/"
      to: "services/url-api/internal/logic/"
      via: "logic constructor in handler function"
      pattern: "logic\\.New.*Logic"
---

<objective>
Create the URL API service with go-zero .api specification, code generation, custom error handling, and stub logic.

Purpose: Establish the URL Service as a bootable go-zero REST service with all routes defined, request validation working, RFC 7807 error handling integrated, and stub responses proving the framework skeleton is functional end-to-end.

Output: Fully generated and customized URL API service that starts on port 8080 and responds to all endpoints.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-framework-foundation/07-RESEARCH.md
@.planning/phases/07-framework-foundation/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write .api spec and generate URL service code</name>
  <files>
    services/url-api/url.api
    services/url-api/internal/config/config.go
    services/url-api/internal/handler/ (generated)
    services/url-api/internal/logic/ (generated)
    services/url-api/internal/svc/servicecontext.go (generated)
    services/url-api/internal/types/types.go (generated)
    services/url-api/url.go (generated)
    services/url-api/etc/url-api.yaml (generated)
  </files>
  <action>
  **Step 1: Write the .api specification file.**

  Create `services/url-api/url.api` with the complete API definition. This is the single source of truth for the URL service.

  ```goapi
  syntax = "v1"

  info (
      title:   "URL Shortener API"
      desc:    "URL shortening and redirect service"
      author:  "go-shortener"
      version: "v2.0"
  )

  // ========== Shorten Types ==========

  type ShortenRequest {
      OriginalUrl string `json:"original_url"`
  }

  type ShortenResponse {
      ShortCode   string `json:"short_code"`
      ShortUrl    string `json:"short_url"`
      OriginalUrl string `json:"original_url"`
  }

  // ========== Link Management Types ==========

  type LinkListRequest {
      Page    int    `form:"page,default=1,range=[1:]"`
      PerPage int    `form:"per_page,default=20,range=[1:100]"`
      Sort    string `form:"sort,default=created_at,options=created_at|original_url"`
      Order   string `form:"order,default=desc,options=asc|desc"`
      Search  string `form:"search,optional"`
  }

  type LinkItem {
      ShortCode   string `json:"short_code"`
      OriginalUrl string `json:"original_url"`
      CreatedAt   int64  `json:"created_at"`
  }

  type LinkListResponse {
      Links      []LinkItem `json:"links"`
      Page       int        `json:"page"`
      PerPage    int        `json:"per_page"`
      TotalPages int        `json:"total_pages"`
      TotalCount int64      `json:"total_count"`
  }

  type LinkDetailRequest {
      Code string `path:"code"`
  }

  type LinkDetailResponse {
      ShortCode   string `json:"short_code"`
      OriginalUrl string `json:"original_url"`
      CreatedAt   int64  `json:"created_at"`
      TotalClicks int64  `json:"total_clicks"`
  }

  type DeleteLinkRequest {
      Code string `path:"code"`
  }

  // ========== Redirect Types ==========

  type RedirectRequest {
      Code string `path:"code"`
  }

  // ========== Service Groups ==========

  @server (
      prefix: /api/v1
      group:  shorten
  )
  service url {
      @doc "Create short URL"
      @handler Shorten
      post /urls (ShortenRequest) returns (ShortenResponse)
  }

  @server (
      group: redirect
  )
  service url {
      @doc "Redirect to original URL"
      @handler Redirect
      get /:code (RedirectRequest)
  }

  @server (
      prefix: /api/v1
      group:  links
  )
  service url {
      @doc "List all links with pagination"
      @handler ListLinks
      get /links (LinkListRequest) returns (LinkListResponse)

      @doc "Get link details"
      @handler GetLinkDetail
      get /links/:code (LinkDetailRequest) returns (LinkDetailResponse)

      @doc "Delete link"
      @handler DeleteLink
      delete /links/:code (DeleteLinkRequest)
  }
  ```

  **Key validation tags used:**
  - `range=[1:]` — page must be >= 1
  - `range=[1:100]` — per_page between 1 and 100
  - `options=created_at|original_url` — sort only allows these values
  - `options=asc|desc` — order only allows these values
  - `default=1` — page defaults to 1 if not provided
  - `optional` — search is not required
  - `path:"code"` — extracts from URL path
  - `form:` — extracts from query parameters
  - `json:` — extracts from request body

  **Step 2: Run goctl to generate service code.**

  ```bash
  cd services/url-api
  goctl api go -api url.api -dir . -style gozero
  ```

  This generates:
  - `url.go` — main entry point
  - `etc/url-api.yaml` — config template
  - `internal/config/config.go` — Config struct
  - `internal/handler/` — handler files grouped by shorten/, redirect/, links/
  - `internal/handler/routes.go` — route registration
  - `internal/logic/` — logic stubs grouped by shorten/, redirect/, links/
  - `internal/svc/servicecontext.go` — ServiceContext
  - `internal/types/types.go` — all request/response types

  **Step 3: Verify generation succeeded.**

  ```bash
  ls services/url-api/internal/handler/
  ls services/url-api/internal/logic/
  ls services/url-api/internal/types/types.go
  ```

  All expected files must exist. If goctl reports syntax errors in the .api file, fix them and regenerate.

  **IMPORTANT: Do NOT edit types.go.** It is regenerated from the .api file. Always edit the .api file and regenerate.
  </action>
  <verify>
  - `ls services/url-api/url.api` exists
  - `ls services/url-api/url.go` exists (generated main)
  - `ls services/url-api/internal/types/types.go` exists
  - `ls services/url-api/internal/handler/routes.go` exists
  - `ls services/url-api/internal/logic/` contains logic files for shorten, redirect, links
  - `ls services/url-api/internal/svc/servicecontext.go` exists
  - `go build ./services/url-api/...` compiles (may need Task 2 customizations first)
  </verify>
  <done>URL Service .api spec written with all routes, types, and validation tags. goctl generates complete handler/logic/types/routes structure without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Customize URL service with error handler, config, and stub logic</name>
  <files>
    services/url-api/url.go
    services/url-api/etc/url-api.yaml
    services/url-api/internal/config/config.go
    services/url-api/internal/svc/servicecontext.go
    services/url-api/internal/logic/shorten/shortenlogic.go
    services/url-api/internal/logic/redirect/redirectlogic.go
    services/url-api/internal/logic/links/listlinkslogic.go
    services/url-api/internal/logic/links/getlinkdetaillogic.go
    services/url-api/internal/logic/links/deletelinklogic.go
    services/url-api/internal/handler/redirect/redirecthandler.go
    Makefile
  </files>
  <action>
  **Step 1: Customize the main entry point (url.go).**

  Edit the generated `services/url-api/url.go` to add:
  1. Custom RFC 7807 error handler via `httpx.SetErrorHandler`
  2. Custom httpx.SetErrorHandlerCtx for context-aware errors (preferred for go-zero)

  The error handler must:
  - Check if error is a go-zero validation error (contains field names from mapping package)
  - For validation errors: return 400 with per-field errors array using `problemdetails.NewValidation`
  - For other errors: return 500 with generic problem details using `problemdetails.New`
  - Use `httpx.SetErrorHandlerCtx` which is the context-aware variant

  Example customization to url.go (after the generated code):
  ```go
  // Add before server.Start():
  httpx.SetErrorHandlerCtx(func(ctx context.Context, err error) (int, interface{}) {
      // go-zero validation errors contain field info
      // Parse and return per-field validation errors
      problem := problemdetails.New(
          http.StatusBadRequest,
          problemdetails.TypeValidationError,
          "Bad Request",
          err.Error(),
      )
      return problem.Status, problem
  })
  ```

  Note: A more sophisticated error handler that parses go-zero validation error strings into per-field errors can be added. For Phase 7, returning the validation error message in the detail field is sufficient. Phase 8 will refine parsing when domain errors are added.

  **Step 2: Customize configuration.**

  Edit `services/url-api/etc/url-api.yaml`:
  ```yaml
  Name: url-api
  Host: 0.0.0.0
  Port: 8080
  Timeout: 30000
  MaxConns: 10000

  Log:
    ServiceName: url-api
    Mode: console
    Level: info

  BaseUrl: http://localhost:8080
  ```

  Edit `services/url-api/internal/config/config.go` to add BaseUrl:
  ```go
  package config

  import "github.com/zeromicro/go-zero/rest"

  type Config struct {
      rest.RestConf
      BaseUrl string
  }
  ```

  **Step 3: Customize ServiceContext (stub for Phase 7).**

  Edit `services/url-api/internal/svc/servicecontext.go`:
  ```go
  package svc

  import "go-shortener/services/url-api/internal/config"

  type ServiceContext struct {
      Config config.Config
      // Phase 8 adds: UrlModel model.UrlModel
      // Phase 9 adds: AnalyticsRpc analyticsclient.Analytics
      // Phase 9 adds: KafkaPusher *kq.Pusher
  }

  func NewServiceContext(c config.Config) *ServiceContext {
      return &ServiceContext{
          Config: c,
      }
  }
  ```

  **Step 4: Implement stub logic for all endpoints.**

  Each logic file should return stub data to prove the skeleton works.

  **shortenlogic.go** — return stub short URL:
  ```go
  func (l *ShortenLogic) Shorten(req *types.ShortenRequest) (resp *types.ShortenResponse, err error) {
      logx.WithContext(l.ctx).Infow("shorten URL", logx.Field("original_url", req.OriginalUrl))
      return &types.ShortenResponse{
          ShortCode:   "stub0001",
          ShortUrl:    l.svcCtx.Config.BaseUrl + "/stub0001",
          OriginalUrl: req.OriginalUrl,
      }, nil
  }
  ```

  **redirectlogic.go** — The redirect handler needs special treatment. The generated handler will try to write a JSON response, but redirect needs to write a 302 response with Location header. For Phase 7 stub, return a simple message indicating redirect is not yet wired (DB needed). The handler itself will need to be customized to do `http.Redirect` in Phase 8. For now, return an error indicating the short code is not found (stub behavior).

  ```go
  func (l *RedirectLogic) Redirect(req *types.RedirectRequest) error {
      logx.WithContext(l.ctx).Infow("redirect", logx.Field("code", req.Code))
      // Phase 7 stub: redirect requires DB lookup (Phase 8)
      // Return not-found for now to prove routing works
      return fmt.Errorf("short code '%s' not found (stub - DB not connected)", req.Code)
  }
  ```

  Note: The redirect handler is special because it doesn't return a JSON response type — it returns nothing in the .api spec. The generated handler will call `redirectLogic.Redirect(req)` and if no error, do nothing. We need to customize the redirect handler to call `http.Redirect(w, r, url, http.StatusFound)` when DB is available in Phase 8. For Phase 7, the error path proves the route works.

  **Customize the redirect handler** (`services/url-api/internal/handler/redirect/redirecthandler.go`):
  The generated handler for a route with no response type just checks for error. This is fine for Phase 7. The handler will be customized in Phase 8 to do HTTP redirect. For now, keep the generated handler as-is — it will return the error through the error handler, proving the RFC 7807 pipeline works.

  **listlinkslogic.go** — return stub paginated list:
  ```go
  func (l *ListLinksLogic) ListLinks(req *types.LinkListRequest) (resp *types.LinkListResponse, err error) {
      logx.WithContext(l.ctx).Infow("list links",
          logx.Field("page", req.Page),
          logx.Field("per_page", req.PerPage),
      )
      return &types.LinkListResponse{
          Links: []types.LinkItem{
              {ShortCode: "stub0001", OriginalUrl: "https://example.com", CreatedAt: 1700000000},
              {ShortCode: "stub0002", OriginalUrl: "https://go-zero.dev", CreatedAt: 1700000001},
          },
          Page:       req.Page,
          PerPage:    req.PerPage,
          TotalPages: 1,
          TotalCount: 2,
      }, nil
  }
  ```

  **getlinkdetaillogic.go** — return stub link detail:
  ```go
  func (l *GetLinkDetailLogic) GetLinkDetail(req *types.LinkDetailRequest) (resp *types.LinkDetailResponse, err error) {
      logx.WithContext(l.ctx).Infow("get link detail", logx.Field("code", req.Code))
      return &types.LinkDetailResponse{
          ShortCode:   req.Code,
          OriginalUrl: "https://example.com/stub",
          CreatedAt:   1700000000,
          TotalClicks: 42,
      }, nil
  }
  ```

  **deletelinklogic.go** — return nil (success stub):
  ```go
  func (l *DeleteLinkLogic) DeleteLink(req *types.DeleteLinkRequest) error {
      logx.WithContext(l.ctx).Infow("delete link", logx.Field("code", req.Code))
      // Phase 8: Delete from database
      return nil
  }
  ```

  **Step 5: Update Makefile with URL service targets.**

  Add to Makefile:
  ```makefile
  .PHONY: run-url gen-url

  run-url: ## Run URL API service
  	go run services/url-api/url.go -f services/url-api/etc/url-api.yaml

  gen-url: ## Regenerate URL API from .api spec
  	cd services/url-api && goctl api go -api url.api -dir . -style gozero
  ```

  **Step 6: Verify the service starts and responds.**

  ```bash
  # Build check
  go build ./services/url-api/...

  # Start service in background, test endpoints, then stop
  go run services/url-api/url.go -f services/url-api/etc/url-api.yaml &
  sleep 2

  # Test shorten endpoint
  curl -s -X POST http://localhost:8080/api/v1/urls -H "Content-Type: application/json" -d '{"original_url":"https://example.com"}'

  # Test list links
  curl -s http://localhost:8080/api/v1/links

  # Test validation (page=0 should fail)
  curl -s "http://localhost:8080/api/v1/links?page=0"

  # Test redirect (should return error in Problem Details format)
  curl -s http://localhost:8080/abc123

  # Test link detail
  curl -s http://localhost:8080/api/v1/links/stub0001

  # Test delete
  curl -s -X DELETE http://localhost:8080/api/v1/links/stub0001

  # Kill background process
  kill %1
  ```
  </action>
  <verify>
  - `go build ./services/url-api/...` compiles without errors
  - Start service, then:
    - `curl -s -X POST http://localhost:8080/api/v1/urls -H "Content-Type: application/json" -d '{"original_url":"https://example.com"}'` returns JSON with short_code, short_url, original_url
    - `curl -s http://localhost:8080/api/v1/links` returns JSON with links array, page, per_page
    - `curl -s "http://localhost:8080/api/v1/links?page=0"` returns error (validation: page must be >= 1)
    - `curl -s "http://localhost:8080/api/v1/links?sort=invalid"` returns error (validation: sort must be created_at or original_url)
    - `curl -s http://localhost:8080/abc123` returns error response (Problem Details format)
    - `curl -s http://localhost:8080/api/v1/links/stub0001` returns link detail JSON
    - `curl -s -X DELETE http://localhost:8080/api/v1/links/stub0001` returns 200
  - Service logs show request method, path, status, latency for each request
  </verify>
  <done>URL Service starts on port 8080 with all routes responding. Shorten returns stub data. Links list/detail/delete return stub data. Validation rejects invalid page/sort/order values. Errors return RFC 7807 Problem Details. Built-in request logging shows method, path, status, latency.</done>
</task>

</tasks>

<verification>
1. `.api` file exists and goctl generates without syntax errors: `cd services/url-api && goctl api go -api url.api -dir . -style gozero`
2. `go build ./services/url-api/...` compiles
3. Service starts: `go run services/url-api/url.go -f services/url-api/etc/url-api.yaml`
4. POST /api/v1/urls returns stub ShortenResponse
5. GET /api/v1/links returns stub LinkListResponse
6. GET /api/v1/links?page=0 returns validation error
7. GET /:code returns error in Problem Details format
8. Request logs visible in console with method/path/status/latency
</verification>

<success_criteria>
- url.api defines 5 routes across 3 groups (shorten, redirect, links)
- goctl generates all handlers, logic, types, routes without errors
- Request validation works: page range, sort options, order options all enforced by tags
- RFC 7807 Problem Details returned for all errors via httpx.SetErrorHandlerCtx
- Config loaded from YAML (port 8080, BaseUrl, log settings)
- ServiceContext initialized with config only (Phase 7 stub)
- All logic functions return stub/TODO responses
- Service boots and responds to curl requests on all endpoints
- Built-in request logging enabled (console mode)
</success_criteria>

<output>
After completion, create `.planning/phases/07-framework-foundation/07-02-SUMMARY.md`
</output>
