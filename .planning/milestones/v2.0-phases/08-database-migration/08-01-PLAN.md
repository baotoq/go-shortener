---
phase: 08-database-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - services/migrations/000001_create_urls.up.sql
  - services/migrations/000001_create_urls.down.sql
  - services/migrations/000002_create_clicks.up.sql
  - services/migrations/000002_create_clicks.down.sql
  - services/url-api/model/urlsmodel.go
  - services/url-api/model/urlsmodel_gen.go
  - services/url-api/model/vars.go
  - services/analytics-rpc/model/clicksmodel.go
  - services/analytics-rpc/model/clicksmodel_gen.go
  - services/analytics-rpc/model/vars.go
  - Makefile
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "PostgreSQL container starts and accepts connections on localhost:5432"
    - "urls table exists with UUIDv7-compatible UUID primary key, short_code unique constraint, and click_count column"
    - "clicks table exists with UUID primary key, short_code column, and timestamptz clicked_at"
    - "goctl-generated model files exist for both urls and clicks tables"
    - "Custom model interfaces extend generated CRUD with pagination, search, and click count methods"
  artifacts:
    - path: "docker-compose.yml"
      provides: "PostgreSQL 16 container configuration"
      contains: "postgres:16-alpine"
    - path: "services/migrations/000001_create_urls.up.sql"
      provides: "urls table DDL"
      contains: "CREATE TABLE urls"
    - path: "services/migrations/000002_create_clicks.up.sql"
      provides: "clicks table DDL"
      contains: "CREATE TABLE clicks"
    - path: "services/url-api/model/urlsmodel.go"
      provides: "Custom URL model methods"
      contains: "UrlsModel"
    - path: "services/analytics-rpc/model/clicksmodel.go"
      provides: "Custom clicks model methods"
      contains: "ClicksModel"
  key_links:
    - from: "docker-compose.yml"
      to: "services/migrations/*.sql"
      via: "PostgreSQL schema initialization"
      pattern: "postgres"
    - from: "services/url-api/model/urlsmodel_gen.go"
      to: "PostgreSQL urls table"
      via: "goctl model pg datasource"
      pattern: "FindOneByShortCode"
---

<objective>
Set up PostgreSQL infrastructure with Docker Compose, create database schema via SQL migrations, and generate goctl models for both urls and clicks tables with custom query methods.

Purpose: Establish the database foundation that both URL API and Analytics RPC services will use. This plan creates the data layer without wiring it to services (Plans 02-03 handle that).

Output: Running PostgreSQL container, migration files, generated + custom model code for both tables.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-database-migration/08-RESEARCH.md
@.planning/phases/08-database-migration/08-CONTEXT.md
@.planning/phases/07-framework-foundation/07-01-SUMMARY.md
@go.mod
@Makefile
@services/url-api/url.api
@services/analytics-rpc/analytics.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose and SQL migrations</name>
  <files>
    docker-compose.yml
    services/migrations/000001_create_urls.up.sql
    services/migrations/000001_create_urls.down.sql
    services/migrations/000002_create_clicks.up.sql
    services/migrations/000002_create_clicks.down.sql
  </files>
  <action>
    Create `docker-compose.yml` at project root with PostgreSQL 16 Alpine:
    - Service name: `postgres`
    - Image: `postgres:16-alpine`
    - Port mapping: `5432:5432`
    - Environment: `POSTGRES_USER=postgres`, `POSTGRES_PASSWORD=postgres`, `POSTGRES_DB=shortener`
    - Volume: `postgres-data:/var/lib/postgresql/data` for persistence
    - Healthcheck: `pg_isready -U postgres` with interval 5s, timeout 5s, retries 5
    - Named volume `postgres-data` at bottom

    Create `services/migrations/` directory with migration files.

    **000001_create_urls.up.sql:**
    ```sql
    CREATE TABLE urls (
      id           UUID PRIMARY KEY,
      short_code   VARCHAR(8) NOT NULL UNIQUE,
      original_url TEXT NOT NULL,
      click_count  BIGINT NOT NULL DEFAULT 0,
      created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
    ```
    Note: No `DEFAULT gen_random_uuid()` on id — application generates UUIDv7 explicitly via `google/uuid.NewV7()`.
    Per user decision: UUIDv7 primary keys, minimal indexes (PK + unique short_code only), no soft delete, no expiration.
    click_count is denormalized per user decision for fast count reads.

    **000001_create_urls.down.sql:**
    ```sql
    DROP TABLE IF EXISTS urls;
    ```

    **000002_create_clicks.up.sql:**
    ```sql
    CREATE TABLE clicks (
      id          UUID PRIMARY KEY,
      short_code  VARCHAR(8) NOT NULL,
      clicked_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE INDEX idx_clicks_short_code ON clicks (short_code);
    ```
    Per research recommendation: add index on clicks.short_code since GetClickCount queries by it.
    Per research recommendation: defer enrichment columns (ip_address, user_agent, referer) to Phase 9.
    Per research recommendation: use TIMESTAMPTZ for clicked_at.

    **000002_create_clicks.down.sql:**
    ```sql
    DROP TABLE IF EXISTS clicks;
    ```

    After creating files, start PostgreSQL and apply migrations:
    ```bash
    docker compose up -d postgres
    # Wait for healthy
    # Apply migrations manually using psql since we only have 2 simple DDL files:
    docker compose exec -T postgres psql -U postgres -d shortener < services/migrations/000001_create_urls.up.sql
    docker compose exec -T postgres psql -U postgres -d shortener < services/migrations/000002_create_clicks.up.sql
    ```
  </action>
  <verify>
    1. `docker compose ps` shows postgres container running and healthy
    2. `docker compose exec postgres psql -U postgres -d shortener -c "\dt"` shows urls and clicks tables
    3. `docker compose exec postgres psql -U postgres -d shortener -c "\d urls"` shows correct columns (id UUID, short_code VARCHAR(8), original_url TEXT, click_count BIGINT, created_at TIMESTAMPTZ)
    4. `docker compose exec postgres psql -U postgres -d shortener -c "\d clicks"` shows correct columns (id UUID, short_code VARCHAR(8), clicked_at TIMESTAMPTZ)
    5. `docker compose exec postgres psql -U postgres -d shortener -c "\di"` shows unique index on urls.short_code and index on clicks.short_code
  </verify>
  <done>PostgreSQL running with urls and clicks tables matching the schema design from CONTEXT.md decisions</done>
</task>

<task type="auto">
  <name>Task 2: Generate goctl models and add custom query methods</name>
  <files>
    services/url-api/model/urlsmodel.go
    services/url-api/model/urlsmodel_gen.go
    services/url-api/model/vars.go
    services/analytics-rpc/model/clicksmodel.go
    services/analytics-rpc/model/clicksmodel_gen.go
    services/analytics-rpc/model/vars.go
    Makefile
    go.mod
    go.sum
  </files>
  <action>
    **Step 1: Generate URL model from PostgreSQL:**
    ```bash
    goctl model pg datasource \
      --url "postgres://postgres:postgres@localhost:5432/shortener?sslmode=disable" \
      --table "urls" \
      --dir services/url-api/model \
      --style gozero
    ```

    **Step 2: Generate clicks model from PostgreSQL:**
    ```bash
    goctl model pg datasource \
      --url "postgres://postgres:postgres@localhost:5432/shortener?sslmode=disable" \
      --table "clicks" \
      --dir services/analytics-rpc/model \
      --style gozero
    ```

    **Step 3: Add `lib/pq` driver dependency:**
    ```bash
    go get github.com/lib/pq
    ```

    **Step 4: Inspect generated code.** Examine `urlsmodel_gen.go` and `clicksmodel_gen.go` to understand:
    - What CRUD methods were generated (Insert, FindOne, FindOneByShortCode, Update, Delete)
    - What the struct fields look like (especially UUID id handling)
    - What `urlsRows` / `clicksRows` variables contain (column list for SELECT)

    **Step 5: Add custom methods to `services/url-api/model/urlsmodel.go`.**
    The generated file has a `customUrlsModel` struct embedding `defaultUrlsModel`. Add these methods to the `UrlsModel` interface and implement on `customUrlsModel`:

    a) `FindByShortCode(ctx context.Context, shortCode string) (*Urls, error)` — Alias for FindOneByShortCode if not already generated. Used by redirect and detail endpoints.

    b) `ListWithPagination(ctx context.Context, cursor string, limit int, search string, sort string, order string) ([]*Urls, int64, error)` — Cursor-based pagination using UUIDv7 id ordering.
       - If cursor is not empty: `WHERE id < $cursor` (descending order — newest first)
       - If search is not empty: add `AND original_url ILIKE $search%` (prefix match per user decision)
       - ORDER BY id DESC (UUIDv7 natural time ordering per user decision)
       - LIMIT $limit
       - Also return total count matching the search filter (separate COUNT query)
       - Note: The .api currently uses page/per_page offset pagination. The logic layer will translate page-based params to cursor-based queries, OR we can keep offset-based for now since the API contract uses page/per_page. Use OFFSET/LIMIT pagination matching the current API contract (page, per_page, sort, order, search). Cursor pagination will be adopted when the API contract changes.

    c) `IncrementClickCount(ctx context.Context, shortCode string) error` — Atomic increment: `UPDATE urls SET click_count = click_count + 1 WHERE short_code = $1`. Never read-modify-write (race condition per research pitfall #4).

    **Step 6: Add custom methods to `services/analytics-rpc/model/clicksmodel.go`.**
    Add to `ClicksModel` interface and implement on `customClicksModel`:

    a) `CountByShortCode(ctx context.Context, shortCode string) (int64, error)` — `SELECT COUNT(*) FROM clicks WHERE short_code = $1`. Used by GetClickCount RPC.

    **Step 7: Add `lib/pq` blank import.** Both model packages need the PostgreSQL driver registered. Add `_ "github.com/lib/pq"` import in each model's vars.go or a dedicated file, OR handle it in the service main.go files (Plan 02/03 will handle the import in main.go or servicecontext.go, so this can be deferred).

    **Step 8: Update Makefile** — Add targets:
    ```makefile
    db-up: ## Start PostgreSQL
    	docker compose up -d postgres

    db-down: ## Stop PostgreSQL
    	docker compose down

    db-migrate: ## Apply database migrations
    	docker compose exec -T postgres psql -U postgres -d shortener < services/migrations/000001_create_urls.up.sql
    	docker compose exec -T postgres psql -U postgres -d shortener < services/migrations/000002_create_clicks.up.sql

    gen-url-model: ## Generate URL model from PostgreSQL
    	goctl model pg datasource --url "postgres://postgres:postgres@localhost:5432/shortener?sslmode=disable" --table "urls" --dir services/url-api/model --style gozero

    gen-clicks-model: ## Generate clicks model from PostgreSQL
    	goctl model pg datasource --url "postgres://postgres:postgres@localhost:5432/shortener?sslmode=disable" --table "clicks" --dir services/analytics-rpc/model --style gozero
    ```

    **Step 9: Run `go mod tidy`** and verify compilation:
    ```bash
    go build ./services/url-api/model/...
    go build ./services/analytics-rpc/model/...
    ```
  </action>
  <verify>
    1. `ls services/url-api/model/` shows urlsmodel.go, urlsmodel_gen.go (or similar named files)
    2. `ls services/analytics-rpc/model/` shows clicksmodel.go, clicksmodel_gen.go (or similar named files)
    3. `go build ./services/url-api/model/...` compiles without errors
    4. `go build ./services/analytics-rpc/model/...` compiles without errors
    5. `grep -c "IncrementClickCount" services/url-api/model/urlsmodel.go` returns 1+ (custom method exists)
    6. `grep -c "CountByShortCode" services/analytics-rpc/model/clicksmodel.go` returns 1+ (custom method exists)
    7. Makefile targets `db-up`, `db-down`, `db-migrate`, `gen-url-model`, `gen-clicks-model` exist
  </verify>
  <done>
    goctl-generated model files exist for both tables with generated CRUD methods.
    Custom methods added: ListWithPagination + IncrementClickCount on UrlsModel, CountByShortCode on ClicksModel.
    All model code compiles successfully. Makefile has DB and model generation targets.
  </done>
</task>

</tasks>

<verification>
1. Docker Compose starts PostgreSQL and tables are created
2. goctl model generates code from live PostgreSQL schema
3. Custom model methods compile alongside generated code
4. Re-running goctl model generation does NOT overwrite custom methods (verify *model.go is untouched, only *model_gen.go regenerated)
5. Makefile provides all database and model generation targets
</verification>

<success_criteria>
- PostgreSQL 16 running in Docker with urls and clicks tables
- urls table: UUID PK, short_code UNIQUE VARCHAR(8), original_url TEXT, click_count BIGINT DEFAULT 0, created_at TIMESTAMPTZ
- clicks table: UUID PK, short_code VARCHAR(8) with index, clicked_at TIMESTAMPTZ
- goctl-generated models for both tables with standard CRUD
- Custom UrlsModel with ListWithPagination and IncrementClickCount
- Custom ClicksModel with CountByShortCode
- All model code compiles: `go build ./services/url-api/model/... ./services/analytics-rpc/model/...`
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-migration/08-01-SUMMARY.md`
</output>
