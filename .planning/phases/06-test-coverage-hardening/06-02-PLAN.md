---
phase: 06-test-coverage-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - test/integration/dapr_test.go
  - test/integration/testutil.go
  - go.mod
  - go.sum
  - Makefile
  - .github/workflows/ci.yml
autonomous: true

must_haves:
  truths:
    - "At least one integration test exercises real Dapr pub/sub message delivery"
    - "At least one integration test exercises real Dapr service invocation"
    - "Integration tests use real Docker containers (not mocks)"
    - "Tests are skipped gracefully when Docker is unavailable (testing.Short or no Docker)"
    - "CI pipeline can run integration tests"
    - "All existing tests continue to pass"
  artifacts:
    - path: "test/integration/dapr_test.go"
      provides: "Dapr integration tests with real sidecars"
      min_lines: 100
    - path: "test/integration/testutil.go"
      provides: "Shared test setup for container orchestration"
      min_lines: 30
  key_links:
    - from: "test/integration/dapr_test.go"
      to: "docker containers"
      via: "testcontainers-go container lifecycle"
      pattern: "testcontainers\\.GenericContainer"
    - from: "test/integration/dapr_test.go"
      to: "URL Service /api/v1/urls"
      via: "HTTP requests to containerized service"
      pattern: "http\\.Post.*api/v1/urls"
    - from: "test/integration/dapr_test.go"
      to: "Analytics Service /analytics/"
      via: "HTTP requests to containerized analytics service"
      pattern: "http\\.Get.*analytics"
---

<objective>
Add Dapr sidecar integration tests that exercise real pub/sub message delivery and service invocation using testcontainers-go. These tests start both services with their Dapr sidecars in Docker containers and verify end-to-end event flow.

Purpose: Close the PROD-02 requirement gap -- no integration tests currently exercise real Dapr sidecars. All existing Dapr tests use mocks.
Output: Integration test files in test/integration/ directory, CI pipeline updated to run them.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-coverage-hardening/06-RESEARCH.md
@docker-compose.yml
@Dockerfile.url-service
@Dockerfile.analytics-service
@dapr/components/pubsub.yaml
@internal/shared/events/click_event.go
@internal/shared/events/link_deleted_event.go
@cmd/url-service/main.go
@cmd/analytics-service/main.go
@internal/urlservice/delivery/http/handler.go
@internal/analytics/delivery/http/handler.go
@.github/workflows/ci.yml
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up testcontainers-go infrastructure and write integration tests</name>
  <files>test/integration/dapr_test.go, test/integration/testutil.go, go.mod, go.sum</files>
  <action>
**Step 1: Add testcontainers-go dependency**

```bash
go get github.com/testcontainers/testcontainers-go@latest
```

**Step 2: Create test/integration/ directory and test infrastructure**

Create `test/integration/testutil.go` (package `integration_test`):

This file provides shared container setup for integration tests. The approach uses Docker Compose via testcontainers-go's `compose` module OR individual containers. Given the project already has a working docker-compose.yml, use the Docker Compose approach for simplicity.

However, the existing docker-compose.yml uses named volumes and persists data. For tests, we need ephemeral containers. Two approaches:
- Option A: Use testcontainers-go's Docker Compose module with the existing docker-compose.yml plus overrides
- Option B: Use individual testcontainers for each service/sidecar

Use Option B (individual containers) because:
1. More control over lifecycle and port mapping
2. Easier to add wait strategies
3. No interference with production docker-compose
4. Cleaner cleanup

The integration test architecture:
1. Build service Docker images from project Dockerfiles
2. Start a Dapr sidecar for each service
3. Use in-memory pub/sub (same as development)
4. Wait for services to be healthy
5. Execute test scenarios via HTTP
6. Verify cross-service event delivery

BUT: This is complex because Dapr sidecars need to communicate with app containers and with each other (for pub/sub). In Docker, this requires shared networking.

SIMPLER APPROACH: Use `docker compose` directly via testcontainers-go's compose support. This leverages the existing docker-compose.yml which already has correct networking (network_mode: service pairing).

Create a `docker-compose.test.yml` that overrides for testing:
- Removes volumes (ephemeral data)
- Maps ports for test access
- Uses tmpfs for database paths

Actually, the SIMPLEST approach for verifying Dapr integration: start both services locally (not in containers) using `go run` with Dapr CLI, then run HTTP-level integration tests against them. But this requires Dapr CLI installed.

RECOMMENDED APPROACH: Use testcontainers-go with Docker Compose. The `testcontainers-go/modules/compose` module can start a Docker Compose stack.

```go
import (
  tc "github.com/testcontainers/testcontainers-go/modules/compose"
)
```

Wait -- testcontainers-go compose module may have version-specific APIs. Let me recommend the most robust approach:

Use `tc.NewDockerCompose()` from testcontainers-go to orchestrate the existing docker-compose.yml. Create a test-specific compose file `test/integration/docker-compose.test.yml` that:
1. Builds images from project root
2. Uses tmpfs for databases
3. Exposes deterministic ports

Actually, let me take the most pragmatic approach. The goal is "at least one integration test exercises real Dapr pub/sub and service invocation". Let's keep it focused:

**testutil.go:**

```go
package integration_test

// Helper constants and functions for integration tests
```

Provide:
- `skipIfShort(t)` - skips if `-short` flag or `SKIP_INTEGRATION` env var is set
- `waitForHealthy(url, timeout)` - polls a health endpoint until ready
- Container setup using testcontainers-go compose module

**Step 3: Create integration tests**

Create `test/integration/dapr_test.go` (package `integration_test`):

Use Go build tags to separate integration tests: add `//go:build integration` at the top. This prevents them from running with `go test ./...` unless explicitly requested with `-tags integration`.

**Test 1: TestDaprPubSub_ClickEventDeliveredToAnalytics**

Full end-to-end test:
1. Start docker-compose stack using testcontainers-go compose module
2. Wait for URL Service to be healthy (GET http://localhost:8080/healthz returns 200)
3. Wait for Analytics Service to be healthy (GET http://localhost:8081/healthz returns 200)
4. Wait for Dapr sidecars to be healthy (readyz endpoints)
5. Create a short URL: POST http://localhost:8080/api/v1/urls with `{"original_url": "https://example.com"}`
6. Visit the short URL: GET http://localhost:8080/{code} (follow=false, expect 302)
7. Wait briefly (1-2 seconds) for async event delivery
8. Query analytics: GET http://localhost:8081/analytics/{code}
9. Assert total_clicks >= 1

This test exercises:
- Real Dapr pub/sub: URL Service publishes ClickEvent -> Analytics Service receives it
- Real HTTP routing and handler execution
- Real SQLite database operations

**Test 2: TestDaprServiceInvocation_ClickCountEnrichment**

1. (Reuse stack from Test 1 or set up fresh)
2. Create a short URL via URL Service
3. Visit it once to generate a click
4. Wait for event processing
5. Query link detail: GET http://localhost:8080/api/v1/links/{code}
6. Assert total_clicks >= 1 (this uses Dapr service invocation: URL Service calls Analytics Service)

This test exercises:
- Real Dapr service invocation: URL Service -> Analytics Service for click count enrichment

**Implementation approach with testcontainers-go compose:**

```go
//go:build integration

package integration_test

import (
  "context"
  "testing"
  "time"

  tc "github.com/testcontainers/testcontainers-go/modules/compose"
  "github.com/testcontainers/testcontainers-go/wait"
)

func TestDaprPubSub_ClickEventDeliveredToAnalytics(t *testing.T) {
  skipIfShort(t)

  ctx := context.Background()

  compose, err := tc.NewDockerCompose("../../docker-compose.yml")
  require.NoError(t, err)

  t.Cleanup(func() {
    require.NoError(t, compose.Down(ctx, tc.RemoveOrphans(true), tc.RemoveVolumes(true)))
  })

  // Start the stack
  err = compose.
    WaitForService("url-service", wait.ForHTTP("/healthz").WithPort("8080/tcp").WithStartupTimeout(60*time.Second)).
    WaitForService("analytics-service", wait.ForHTTP("/healthz").WithPort("8081/tcp").WithStartupTimeout(60*time.Second)).
    Up(ctx, tc.Wait(true))
  require.NoError(t, err)

  // ... test logic ...
}
```

IMPORTANT CAVEAT: The docker-compose.yml uses `network_mode: "service:url-service"` for the Dapr sidecar, which means the sidecar shares the network namespace of the service. The ports exposed are from the service container. This should work with testcontainers-go compose.

However, there's a timing issue: the Dapr sidecar healthcheck (wget http://localhost:3500/v1.0/healthz) needs time. The compose health check has `start_period: 30s`. We need to wait for BOTH the service AND its sidecar to be healthy.

The WaitForService on url-service checks port 8080 (the app), but doesn't check 3500 (the sidecar). For the readyz endpoint (which checks Dapr), we can poll /readyz instead of /healthz.

Revised approach: Wait for /readyz to return 200 (which checks both DB and Dapr sidecar):
```go
WaitForService("url-service", wait.ForHTTP("/readyz").WithPort("8080/tcp").WithStartupTimeout(90*time.Second))
```

BUT: The /readyz check makes an HTTP call to localhost:3500 which is the Dapr sidecar. If the sidecar isn't ready, readyz returns 503. So polling /readyz with a long timeout should eventually succeed once the sidecar is up.

For Analytics Service: its readyz only checks the DB (no Dapr check in analytics handler.go). So /healthz is sufficient.

Actually, looking at the analytics handler, Readyz checks DB only. But for the click event to be received, the Dapr sidecar for analytics must be running and subscribed. We should wait for the Dapr sidecar health check too. Since the analytics sidecar is on network_mode service:analytics-service, we can check http://analytics-service-host:3500/v1.0/healthz from outside... but that's complex.

PRAGMATIC APPROACH: Wait for both services' /healthz, then add a polling loop for the actual test assertion (retry the analytics query for up to 30 seconds to account for Dapr sidecar startup and event propagation).

**Important notes for the implementation:**

1. Use `//go:build integration` build tag so these tests don't run with `go test ./...`
2. Use `testing.Short()` skip as a fallback
3. Keep timeouts generous (60-90s for startup, 30s for event propagation)
4. Clean up containers in t.Cleanup
5. The docker-compose.yml maps ports 8080 and 8081 to the host. In CI (GitHub Actions), these ports should be available.
6. For the GeoIP database volume mount in docker-compose.yml (`./data/GeoLite2-Country.mmdb`), the file may not exist in CI. The Analytics Service handles this gracefully (falls back to "Unknown"), so it won't block tests.

**Alternative if testcontainers-go compose has API issues:**

Fall back to using `os/exec` to run `docker compose up -d` and `docker compose down` directly. This is simpler and guaranteed to work with the existing docker-compose.yml.

```go
func startStack(t *testing.T) {
  cmd := exec.Command("docker", "compose", "-f", "../../docker-compose.yml", "up", "--build", "-d")
  out, err := cmd.CombinedOutput()
  require.NoError(t, err, string(out))

  t.Cleanup(func() {
    exec.Command("docker", "compose", "-f", "../../docker-compose.yml", "down", "-v", "--remove-orphans").Run()
  })
}
```

Use whichever approach compiles and works. The testcontainers-go compose module is preferred, but `os/exec` with `docker compose` is acceptable.

Use 2-space indentation. Use TestX_Condition_ExpectedOutcome naming.
  </action>
  <verify>
Run `go build ./test/integration/...` - compiles without errors.
Run `go test -tags integration -v -timeout 5m ./test/integration/` - both tests pass (requires Docker running).
Run `go test -short ./test/integration/` - tests are skipped.
Run `go test -race ./...` - existing tests still pass (integration tests excluded by build tag).
  </verify>
  <done>
2 integration tests pass with real Dapr sidecars. Test 1 verifies pub/sub click event delivery (URL Service -> Analytics Service). Test 2 verifies service invocation click count enrichment (URL Service -> Analytics Service). Tests skip gracefully without Docker.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CI pipeline and Makefile for integration tests</name>
  <files>.github/workflows/ci.yml, Makefile</files>
  <action>
**Step 1: Update Makefile**

Add integration test target:

```makefile
# Run integration tests (requires Docker)
test-integration:
	go test -tags integration -v -timeout 5m ./test/integration/

# Run all CI checks locally (including integration)
ci-full: lint test-coverage build test-integration
```

Keep existing `ci` target as-is (fast, no Docker needed).

**Step 2: Update CI pipeline**

Add an integration test job to `.github/workflows/ci.yml` that runs after the build job. GitHub Actions ubuntu-latest has Docker pre-installed.

Add a new job `integration-test`:

```yaml
  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Run integration tests
        run: go test -tags integration -v -timeout 5m ./test/integration/
```

This job:
- Runs after build (depends on lint and test passing)
- Uses ubuntu-latest which has Docker pre-installed
- Runs with -timeout 5m to prevent hanging if containers fail
- Uses -tags integration to include the integration test files

NOTE: The integration tests build Docker images from Dockerfiles, which requires the full source code. The checkout step provides this.

NOTE: If the GeoIP database file (data/GeoLite2-Country.mmdb) is not in the repo, create a placeholder or skip the volume mount. The Analytics Service handles this gracefully (falls back to "Unknown" for geo-location).

Ensure the integration test job does NOT block merging -- if integration tests are flaky due to Docker timing, consider making the job `continue-on-error: true` initially. But start strict and relax only if needed.
  </action>
  <verify>
Run `make test-integration` locally - integration tests execute (pass if Docker available, skip otherwise).
Verify `.github/workflows/ci.yml` is valid YAML: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"`
Run `make ci` - existing CI checks still pass.
  </verify>
  <done>
Makefile has `test-integration` and `ci-full` targets. CI pipeline includes integration-test job that runs after build. Integration tests will execute in GitHub Actions with real Docker containers.
  </done>
</task>

</tasks>

<verification>
1. `go test -tags integration -v -timeout 5m ./test/integration/` - integration tests pass with real Dapr sidecars
2. `go test -race ./...` - all existing unit tests still pass (integration tests excluded by default)
3. `go test -short -tags integration ./test/integration/` - tests skip gracefully
4. `make test-integration` - Makefile target works
5. CI YAML is valid and includes integration-test job
</verification>

<success_criteria>
- At least one integration test exercises real Dapr pub/sub (click event published by URL Service, received by Analytics Service)
- At least one integration test exercises real Dapr service invocation (URL Service queries Analytics Service for click count)
- Tests use real Docker containers, not mocks
- Tests are separated by build tag (don't run in normal `go test ./...`)
- CI pipeline runs integration tests after unit tests pass
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-coverage-hardening/06-02-SUMMARY.md`
</output>
