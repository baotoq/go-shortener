---
phase: 06-test-coverage-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/urlservice/delivery/http/handler.go
  - internal/urlservice/delivery/http/handler_test.go
  - internal/urlservice/delivery/http/middleware_test.go
  - internal/urlservice/delivery/http/router_test.go
autonomous: true

must_haves:
  truths:
    - "URL handler package test coverage reaches 80%+ (currently 44.6%)"
    - "Rate limiter middleware correctly limits requests per IP"
    - "Logger middleware logs requests with status code and duration"
    - "Router wires health checks outside rate limiter and business routes inside"
    - "Readyz handler reports database and Dapr sidecar status"
    - "publishClickEvent fires Dapr publish after redirect"
    - "All existing tests continue to pass"
  artifacts:
    - path: "internal/urlservice/delivery/http/middleware_test.go"
      provides: "Rate limiter and logger middleware unit tests"
      min_lines: 80
    - path: "internal/urlservice/delivery/http/router_test.go"
      provides: "Router integration tests verifying route wiring and middleware order"
      min_lines: 40
    - path: "internal/urlservice/delivery/http/handler_test.go"
      provides: "Extended handler tests covering Readyz, publishClickEvent, and missing error paths"
      min_lines: 500
  key_links:
    - from: "internal/urlservice/delivery/http/middleware_test.go"
      to: "RateLimiter.Middleware"
      via: "httptest with multiple requests from same IP"
      pattern: "rl\\.Middleware.*ServeHTTP"
    - from: "internal/urlservice/delivery/http/router_test.go"
      to: "NewRouter"
      via: "full router ServeHTTP with httptest"
      pattern: "NewRouter.*ServeHTTP"
    - from: "internal/urlservice/delivery/http/handler_test.go"
      to: "publishClickEvent"
      via: "mock DaprClient with sync.WaitGroup"
      pattern: "PublishEvent.*WaitGroup"
---

<objective>
Raise URL Service handler package test coverage from 44.6% to 80%+ by adding unit tests for all uncovered code paths: middleware (rate limiter, logger), router setup, readiness probe, fire-and-forget click event publishing, and missing handler error paths.

Purpose: Close the handler coverage gap identified in the v1.0 milestone audit. The handler package has 0% coverage on middleware, router, Readyz, and publishClickEvent.
Output: Three test files (middleware_test.go, router_test.go, extended handler_test.go) bringing package coverage above 80%.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-coverage-hardening/06-RESEARCH.md
@internal/urlservice/delivery/http/handler.go
@internal/urlservice/delivery/http/middleware.go
@internal/urlservice/delivery/http/router.go
@internal/urlservice/delivery/http/response.go
@internal/urlservice/delivery/http/handler_test.go
@internal/urlservice/usecase/dapr_client.go
@internal/testutil/dapr_mock.go
@.coverage.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Middleware unit tests (rate limiter + logger)</name>
  <files>internal/urlservice/delivery/http/middleware_test.go</files>
  <action>
Create `middleware_test.go` in the `http_test` package (external test package, same as handler_test.go). Use `httphandler "go-shortener/internal/urlservice/delivery/http"` import alias.

IMPORTANT: The `RateLimiter` struct fields are unexported, so tests must use exported API only: `NewRateLimiter(requestsPerMinute)` and `rl.Middleware(handler)`.

**Rate Limiter Tests (table-driven):**

1. `TestRateLimiter_Middleware_WithinLimit_Returns200` - Create RateLimiter with high limit (100), send 5 requests from same IP, verify all return 200 and X-RateLimit-Limit header is set.

2. `TestRateLimiter_Middleware_ExceedsLimit_Returns429` - Create RateLimiter with limit=2, send 3 requests from same IP "192.168.1.1:12345", verify first 2 return 200 and third returns 429 with RFC 7807 Problem Details (Content-Type: application/problem+json, type contains "rate-limit-exceeded").

3. `TestRateLimiter_Middleware_DifferentIPs_IndependentLimits` - Create RateLimiter with limit=1, send 1 request from "10.0.0.1:1234" (200), then 1 request from "10.0.0.2:5678" (200). Different IPs should have independent limits.

4. `TestRateLimiter_Middleware_SetsHeaders` - Verify X-RateLimit-Limit and X-RateLimit-Remaining headers are set on successful requests. X-RateLimit-Reset should be set on 429 responses.

For each test, create a fresh `NewRateLimiter(N)` instance (each test gets its own to avoid shared state). Use a simple `http.HandlerFunc` that writes 200 as the next handler. Use `httptest.NewRecorder()` and `httptest.NewRequest()`.

NOTE: `NewRateLimiter` calls `StartCleanup()` which starts a goroutine. This will cause goroutine leaks in tests but is acceptable since (a) the ticker fires every 10 minutes so won't fire during tests, and (b) fixing this requires production code changes (adding StopCleanup) which is out of scope for coverage hardening.

**Logger Middleware Tests:**

5. `TestLoggerMiddleware_LogsRequest` - Create LoggerMiddleware with `zap.NewNop()` (or use `zaptest.NewRecorder()` if needed), send a request through it, verify the next handler is called and the response status code is preserved. The key goal is to cover the LoggerMiddleware function and verify it wraps the response writer and calls next.ServeHTTP.

6. `TestLoggerMiddleware_PreservesStatusCode` - Verify that when the inner handler writes a non-200 status (e.g., 404), the middleware preserves it. Create inner handler that writes 404, wrap with LoggerMiddleware, verify recorder gets 404.

Use 2-space indentation per project convention (.editorconfig).
Use TestX_Condition_ExpectedOutcome naming pattern.
  </action>
  <verify>
Run `go test -v -run 'TestRateLimiter|TestLoggerMiddleware' ./internal/urlservice/delivery/http/` - all tests pass.
Run `go test -cover ./internal/urlservice/delivery/http/` - coverage should increase from 44.6% to approximately 60-65%.
  </verify>
  <done>
6 middleware tests pass. Rate limiter correctly enforces per-IP limits, returns 429 with Problem Details, sets rate limit headers. Logger middleware covers request logging code path. Package coverage improves by ~15-20 percentage points.
  </done>
</task>

<task type="auto">
  <name>Task 2: Handler gap tests (Readyz, publishClickEvent, missing error paths) + handler refactor for testable Dapr client</name>
  <files>internal/urlservice/delivery/http/handler.go, internal/urlservice/delivery/http/handler_test.go</files>
  <action>
**Step 1: Refactor handler to use DaprClient interface (small, surgical change)**

The handler currently accepts `dapr.Client` (the full Dapr SDK interface with ~40 methods), making it impossible to mock for `publishClickEvent` tests. Change the handler to accept the existing `usecase.DaprClient` interface instead (only has PublishEvent, InvokeMethod, Close).

In `handler.go`:
- Change import: add `"go-shortener/internal/urlservice/usecase"`, remove the direct dapr import for the client type (keep it only if needed elsewhere).
- Change field: `daprClient dapr.Client` -> `daprClient usecase.DaprClient`
- Change constructor: `NewHandler(service *usecase.URLService, baseURL string, daprClient usecase.DaprClient, logger *zap.Logger, db *sql.DB) *Handler`
- The `publishClickEvent` method calls `h.daprClient.PublishEvent(ctx, pubsubName, topicName, data)` which matches the `DaprClient` interface. No other changes needed.

Verify: Run `go build ./...` to confirm no compilation errors. Run `go test ./...` to confirm all existing tests still pass (existing tests pass nil for daprClient, so the interface change is transparent).

NOTE: The dapr import `dapr "github.com/dapr/go-sdk/client"` may still be needed if `PublishEventOption` type is referenced. Check if `usecase.DaprClient.PublishEvent` signature uses `dapr.PublishEventOption` - if so, keep the dapr import for the type but use `usecase.DaprClient` for the field type. Actually, looking at usecase/dapr_client.go, the interface already imports dapr and uses `dapr.PublishEventOption` in its signature. So the handler just needs to change the field/constructor type. The dapr import can likely be removed from handler.go since it's no longer referencing `dapr.Client` directly. But verify before removing - if handler.go uses any other dapr types directly, keep the import.

**Step 2: Add handler tests for uncovered paths**

Add these tests to the existing `handler_test.go`:

**Readyz tests (using DATA-SOURCES-TESTDB or sqlmock):**

For Readyz, the handler calls `h.db.PingContext(ctx)`. Two approaches:
- Option A (preferred): Use an in-memory SQLite database for the "healthy" test and a closed database for the "unhealthy" test.
- Option B: Use `github.com/DATA-DOG/go-sqlmock` - but this adds a new dependency.

Use Option A (in-memory SQLite, already a project dependency via modernc.org/sqlite):

1. `TestReadyz_DatabaseHealthy_NoDapr_Returns200` - Create handler with in-memory SQLite (`sql.Open("sqlite", ":memory:"`)), nil daprClient. Call Readyz. Verify 200 with `{"status": "ready"}`.

2. `TestReadyz_DatabaseUnavailable_Returns503` - Create handler with a closed SQLite database (open then immediately close). Call Readyz. Verify 503 with `{"status": "unavailable", "reason": "database unavailable: ..."}`.

3. `TestReadyz_DaprSidecarUnavailable_Returns503` - Create handler with healthy DB, non-nil mock DaprClient. Since Readyz makes an HTTP call to localhost:3500, and that port won't be listening in tests, the HTTP client will fail with connection refused. Verify 503 with reason containing "dapr sidecar unavailable".

For test 3, update `setupTestHandler` or create a new helper `setupTestHandlerWithDapr` that provides a mock DaprClient (from `testutil.MockDaprClient`). Note: after the refactor in Step 1, the handler accepts `usecase.DaprClient`, so `testutil.MockDaprClient` should satisfy the interface (verify it implements PublishEvent, InvokeMethod, Close). If `testutil.MockDaprClient` doesn't satisfy `usecase.DaprClient`, add the `ConverseAlpha1` method or verify the interface match.

Actually, checking: `usecase.DaprClient` interface has InvokeMethod, PublishEvent, Close. The `testutil.MockDaprClient` has all three plus ConverseAlpha1 (panics). Since Go interfaces are structural, MockDaprClient satisfies DaprClient as long as the method signatures match exactly. Verify the signatures match - particularly PublishEvent's variadic `opts ...dapr.PublishEventOption`.

**publishClickEvent tests:**

4. `TestRedirect_WithDaprClient_PublishesClickEvent` - Create handler with mock DaprClient. Set up mock to expect `PublishEvent(ctx, "pubsub", "clicks", data)`. Use `sync.WaitGroup` to wait for the goroutine. Create chi router with redirect route. Send request with RemoteAddr, User-Agent, and Referer headers. Verify:
   - 302 redirect happens
   - PublishEvent was called (via mock assertion)
   - Event data contains correct short_code, client_ip, user_agent, referer

Use the WaitGroup pattern from the research:
```go
var wg sync.WaitGroup
wg.Add(1)
mockDapr.On("PublishEvent", mock.Anything, "pubsub", "clicks", mock.Anything).
  Run(func(args mock.Arguments) {
    defer wg.Done()
  }).Return(nil)
// ... trigger redirect ...
// Wait with timeout
```

5. `TestRedirect_PublishEventFails_StillRedirects` - Create handler with mock DaprClient that returns error from PublishEvent. Verify redirect still returns 302 (fire-and-forget behavior).

**Missing handler error paths:**

6. `TestGetURLDetails_NotFound_Returns404` - Test GetURLDetails when repo returns ErrURLNotFound. Currently only the "exists" path is tested. Use chi router.

7. `TestGetURLDetails_ServerError_Returns500` - Test GetURLDetails when repo returns generic error. Use chi router.

8. `TestGetLinkDetail_ServerError_Returns500` - Test GetLinkDetail when repo returns generic error (not ErrURLNotFound). Use chi router.

9. `TestRedirect_ServerError_Returns500` - Test Redirect when repo returns generic error (not ErrURLNotFound). Use chi router.

10. `TestCreateShortURL_ShortCodeConflict_Returns500` - Test CreateShortURL when service returns ErrShortCodeConflict (max retries exceeded).

For tests needing `sql.DB` for Readyz, create a helper `setupTestHandlerWithDB(t *testing.T) (*httphandler.Handler, *mocks.MockURLRepository, *sql.DB)` that opens an in-memory SQLite and returns the DB for cleanup. Import `_ "modernc.org/sqlite"` for the driver.

For tests needing mock DaprClient, create a helper `setupTestHandlerWithDapr(t *testing.T) (*httphandler.Handler, *mocks.MockURLRepository, *testutil.MockDaprClient)`.

Use 2-space indentation. Use TestX_Condition_ExpectedOutcome naming.
  </action>
  <verify>
Run `go build ./...` - no compilation errors after handler refactor.
Run `go test -v ./internal/urlservice/delivery/http/` - all tests pass (existing + new).
Run `go test -cover ./internal/urlservice/delivery/http/` - coverage should be approximately 75-85%.
Run `go tool cover -func=coverage.out` after `go test -coverprofile=coverage.out ./internal/urlservice/delivery/http/` to verify:
  - publishClickEvent: >0% (was 0%)
  - Readyz: >0% (was 0%)
  - GetURLDetails: >70% (was 41.7%)
  - Redirect: >80% (was 77.8%)
  </verify>
  <done>
Handler refactored to use DaprClient interface. 10+ new handler tests covering: Readyz (healthy DB, unhealthy DB, Dapr unavailable), publishClickEvent (success, failure), and all missing error paths (GetURLDetails 404/500, GetLinkDetail 500, Redirect 500, CreateShortURL conflict). publishClickEvent coverage > 0%. Readyz coverage > 0%.
  </done>
</task>

<task type="auto">
  <name>Task 3: Router integration tests and coverage verification</name>
  <files>internal/urlservice/delivery/http/router_test.go, .coverage.yaml</files>
  <action>
Create `router_test.go` in the `http_test` package.

**Router Tests:**

These tests verify that `NewRouter` correctly wires routes and middleware order. They use the full router (not individual handlers) to test the complete request path.

1. `TestNewRouter_HealthCheckRoute_BypassesRateLimit` - Create a RateLimiter with limit=0 (or limit=1 and send 2 requests). Create NewRouter with handler, logger, rateLimiter. Send GET /healthz. Verify it returns 200 even though rate limit is 0/exhausted. This proves health checks are outside the rate limiter middleware group.

2. `TestNewRouter_ReadyzRoute_BypassesRateLimit` - Same as above but for GET /readyz. Since Readyz needs a working DB, create handler with in-memory SQLite and nil DaprClient. Verify 200 with rate limit exhausted.

3. `TestNewRouter_BusinessRoute_RateLimited` - Create NewRouter with RateLimiter(limit=1). Send 2 requests to POST /api/v1/urls (with valid body). Second request should get 429. This proves business routes go through rate limiter.

4. `TestNewRouter_RedirectRoute_Registered` - Send GET /abc123 through the full router. Verify it reaches the Redirect handler (returns 404 via mock, not 405 Method Not Allowed). This proves /{code} route is registered.

5. `TestNewRouter_APIRoutes_Registered` - Send requests to each API route (POST /api/v1/urls, GET /api/v1/urls/{code}, GET /api/v1/links, GET /api/v1/links/{code}, DELETE /api/v1/links/{code}). Verify they don't return 404/405 (they will return business-logic responses or errors, which is fine - we just verify routing works).

For router tests, you need a real Handler with mocked dependencies. Use `setupTestHandler(t)` for most tests. For tests involving Readyz, use `setupTestHandlerWithDB(t)` from Task 2.

NOTE: For rate limit test with limit=0, NewRateLimiter(0) may panic due to division by zero in `rate.Every(time.Minute / time.Duration(0))`. Use limit=1 instead and send 2 requests - first succeeds, second fails.

**Coverage verification:**

After all three tasks, run:
```bash
go test -coverprofile=coverage.out -covermode=atomic ./internal/urlservice/delivery/http/
go tool cover -func=coverage.out
```

Verify total is >= 80%. If it's slightly below (e.g., 78-79%), check which functions still have low coverage and add targeted tests. The StartCleanup goroutine (lines 94-108) may be hard to cover without production changes - that's acceptable since it's 6 lines.

**Update .coverage.yaml if needed:**

If the package threshold of 70% is already passing, no changes needed. The total threshold of 80% should now pass with the handler package at 80%+. Verify by running:
```bash
go test -coverprofile=coverage.out -covermode=atomic ./...
go-test-coverage --config=.coverage.yaml
```

If go-test-coverage is not installed, install with: `go install github.com/vladopajic/go-test-coverage/v2@latest`

Use 2-space indentation. Use TestX_Condition_ExpectedOutcome naming.
  </action>
  <verify>
Run `go test -v -run 'TestNewRouter' ./internal/urlservice/delivery/http/` - all router tests pass.
Run `go test -coverprofile=coverage.out -covermode=atomic ./internal/urlservice/delivery/http/ && go tool cover -func=coverage.out | grep total` - shows >= 80%.
Run `go test -coverprofile=coverage.out -covermode=atomic ./... && go-test-coverage --config=.coverage.yaml` - all thresholds pass.
Run `go test -race ./...` - all project tests pass with no race conditions.
  </verify>
  <done>
5 router integration tests pass. NewRouter coverage > 0% (was 0%). Full package coverage >= 80%. go-test-coverage thresholds pass. All existing tests still pass. No race conditions.
  </done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/urlservice/delivery/http/` - ALL tests pass (existing 16 + new ~21)
2. `go test -coverprofile=coverage.out -covermode=atomic ./internal/urlservice/delivery/http/ && go tool cover -func=coverage.out | grep total` - total >= 80%
3. `go test -race ./...` - all project tests pass, no race conditions
4. `go-test-coverage --config=.coverage.yaml` - all coverage thresholds pass (total 80%, package 70%)
5. Per-function verification via `go tool cover -func=coverage.out`:
   - NewRateLimiter: > 0%
   - getLimiter: > 0%
   - Middleware: > 0%
   - LoggerMiddleware: > 0%
   - NewRouter: > 0%
   - Readyz: > 0%
   - publishClickEvent: > 0%
</verification>

<success_criteria>
- URL handler package test coverage >= 80% (up from 44.6%)
- All previously uncovered functions now have test coverage (middleware, router, Readyz, publishClickEvent)
- All existing tests continue to pass
- go-test-coverage thresholds pass
- No race conditions detected
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-coverage-hardening/06-01-SUMMARY.md`
</output>
