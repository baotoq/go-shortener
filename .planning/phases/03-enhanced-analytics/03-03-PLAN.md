---
phase: 03-enhanced-analytics
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - internal/analytics/usecase/analytics_service.go
  - internal/analytics/delivery/http/handler.go
  - internal/analytics/delivery/http/response.go
  - internal/analytics/delivery/http/router.go
  - cmd/analytics-service/main.go
autonomous: true

must_haves:
  truths:
    - "Analytics Service enriches click events with country, device type, and traffic source at ingest time"
    - "GET /analytics/{code}/summary returns total clicks plus breakdowns by country, device type, and traffic source with counts and percentages"
    - "GET /analytics/{code}/clicks returns cursor-paginated individual click records with enrichment data"
    - "Both summary and detail endpoints support ?from=YYYY-MM-DD&to=YYYY-MM-DD time-range filtering"
    - "Enrichment failures (GeoIP miss, bad UA, invalid referer) never block click recording — store 'Unknown'/'Direct'"
    - "GeoIP database is loaded once at startup and injected into the service"
  artifacts:
    - path: "internal/analytics/usecase/analytics_service.go"
      provides: "Enrichment orchestration and query methods"
      contains: "RecordEnrichedClick"
    - path: "internal/analytics/delivery/http/handler.go"
      provides: "Summary and detail HTTP handlers with time-range parsing"
      contains: "GetAnalyticsSummary"
    - path: "internal/analytics/delivery/http/response.go"
      provides: "Response types with breakdowns and percentages"
      contains: "AnalyticsSummary"
    - path: "internal/analytics/delivery/http/router.go"
      provides: "Routes for summary and detail endpoints"
      contains: "/analytics/{code}/summary"
    - path: "cmd/analytics-service/main.go"
      provides: "Wiring of enrichment services at startup"
      contains: "NewGeoIPResolver"
  key_links:
    - from: "internal/analytics/usecase/analytics_service.go"
      to: "internal/analytics/enrichment/geoip.go"
      via: "GeoIPResolver injected and called in RecordEnrichedClick"
      pattern: "geoIP\\.ResolveCountry"
    - from: "internal/analytics/usecase/analytics_service.go"
      to: "internal/analytics/enrichment/useragent.go"
      via: "DeviceDetector injected and called in RecordEnrichedClick"
      pattern: "deviceDetector\\.DetectDevice"
    - from: "internal/analytics/usecase/analytics_service.go"
      to: "internal/analytics/enrichment/referer.go"
      via: "RefererClassifier injected and called in RecordEnrichedClick"
      pattern: "refererClassifier\\.ClassifySource"
    - from: "internal/analytics/delivery/http/handler.go"
      to: "internal/analytics/usecase/analytics_service.go"
      via: "Handler calls service for summary and detail queries"
      pattern: "analyticsService\\.GetAnalyticsSummary"
    - from: "cmd/analytics-service/main.go"
      to: "internal/analytics/enrichment/geoip.go"
      via: "GeoIPResolver created at startup with database path"
      pattern: "enrichment\\.NewGeoIPResolver"
---

<objective>
Wire enrichment services into the Analytics Service, create summary and detail HTTP endpoints, and update the event handler to enrich clicks at ingest time.

Purpose: This plan connects all the pieces: enrichment services (Plan 01) process the data from extended click events, and the repository (Plan 02) stores and queries the enriched data. The result is a fully functional analytics API that returns geo-location breakdowns, device type distributions, traffic source classifications, and individual click details with cursor pagination.

Output: Updated AnalyticsService with enrichment orchestration, summary endpoint (GET /analytics/{code}/summary), detail endpoint (GET /analytics/{code}/clicks), time-range filtering, and startup wiring in main.go.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-enhanced-analytics/03-RESEARCH.md
@.planning/phases/03-enhanced-analytics/03-CONTEXT.md
@.planning/phases/03-enhanced-analytics/03-01-SUMMARY.md
@.planning/phases/03-enhanced-analytics/03-02-SUMMARY.md
@internal/analytics/usecase/analytics_service.go
@internal/analytics/delivery/http/handler.go
@internal/analytics/delivery/http/response.go
@internal/analytics/delivery/http/router.go
@cmd/analytics-service/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AnalyticsService with enrichment orchestration and query methods</name>
  <files>
    internal/analytics/usecase/analytics_service.go
  </files>
  <action>
1. **Rewrite `internal/analytics/usecase/analytics_service.go`** to add enrichment and query capabilities:

   - **Dependencies:** Add three enrichment service fields to the struct. Define interfaces or use concrete types from the enrichment package. For simplicity, define local interfaces for testability:
     ```go
     type GeoIPResolver interface {
         ResolveCountry(ipStr string) string
     }
     type DeviceDetector interface {
         DetectDevice(uaString string) string
     }
     type RefererClassifier interface {
         ClassifySource(refererStr string) string
     }
     ```

   - **Update struct:**
     ```go
     type AnalyticsService struct {
         repo              ClickRepository
         geoIP             GeoIPResolver
         deviceDetector    DeviceDetector
         refererClassifier RefererClassifier
     }
     ```

   - **Update constructor:** `NewAnalyticsService(repo ClickRepository, geoIP GeoIPResolver, deviceDetector DeviceDetector, refererClassifier RefererClassifier) *AnalyticsService`

   - **Add `RecordEnrichedClick` method:**
     ```go
     func (s *AnalyticsService) RecordEnrichedClick(ctx context.Context, event events.ClickEvent) error {
         countryCode := s.geoIP.ResolveCountry(event.ClientIP)
         deviceType := s.deviceDetector.DetectDevice(event.UserAgent)
         trafficSource := s.refererClassifier.ClassifySource(event.Referer)
         return s.repo.InsertClick(ctx, event.ShortCode, event.Timestamp.Unix(), countryCode, deviceType, trafficSource)
     }
     ```

   - **Update `RecordClick`:** Change to call `RecordEnrichedClick` internally (so the event handler can call either). Or simply remove the old `RecordClick` and update the handler in Task 2 to call `RecordEnrichedClick`.

   - **Keep `GetClickCount`** method unchanged (backward compatibility for existing `/analytics/{code}` endpoint).

   - **Add `AnalyticsSummary` result type:**
     ```go
     type BreakdownItem struct {
         Value      string
         Count      int64
         Percentage float64  // e.g., 58.3
     }

     type AnalyticsSummaryResult struct {
         ShortCode      string
         TotalClicks    int64
         Countries      []BreakdownItem
         DeviceTypes    []BreakdownItem
         TrafficSources []BreakdownItem
     }
     ```

   - **Add `GetAnalyticsSummary` method:**
     ```go
     func (s *AnalyticsService) GetAnalyticsSummary(ctx context.Context, shortCode string, from int64, to int64) (*AnalyticsSummaryResult, error)
     ```
     - Call `s.repo.CountInRange(ctx, shortCode, from, to)` for total
     - Call `s.repo.CountByCountryInRange(...)`, `CountByDeviceInRange(...)`, `CountBySourceInRange(...)` for breakdowns
     - Convert each `[]GroupCount` to `[]BreakdownItem` by calculating percentage: `(count / total) * 100`, rounded to 1 decimal
     - Return assembled `AnalyticsSummaryResult`

   - **Add `GetClickDetails` method:**
     ```go
     func (s *AnalyticsService) GetClickDetails(ctx context.Context, shortCode string, cursorTimestamp int64, limit int) (*PaginatedClicks, error)
     ```
     - Delegate directly to `s.repo.GetClickDetails(ctx, shortCode, cursorTimestamp, limit)`
     - If limit <= 0 or > 100, default to 20

   - Import: `"context"`, `"go-shortener/internal/shared/events"`
  </action>
  <verify>
    Run `go build ./internal/analytics/usecase/...` — must compile (note: main.go will fail until Task 2 updates constructor call, but the package itself should compile).
    Run `go vet ./internal/analytics/usecase/...` — no issues.
    Grep for `RecordEnrichedClick` in analytics_service.go.
    Grep for `GetAnalyticsSummary` in analytics_service.go.
    Grep for `GetClickDetails` in analytics_service.go.
  </verify>
  <done>AnalyticsService orchestrates enrichment at ingest time (GeoIP + UA + Referer), provides summary queries with percentage calculations, and delegates cursor-paginated detail queries to repository.</done>
</task>

<task type="auto">
  <name>Task 2: Create summary/detail HTTP handlers, update event handler, router, and main.go wiring</name>
  <files>
    internal/analytics/delivery/http/handler.go
    internal/analytics/delivery/http/response.go
    internal/analytics/delivery/http/router.go
    cmd/analytics-service/main.go
  </files>
  <action>
1. **Update `internal/analytics/delivery/http/response.go`** — add response types:
   - Keep existing `writeJSON` and `writeProblem` functions.
   - Add response types:
     ```go
     type BreakdownResponse struct {
         Value      string `json:"value"`
         Count      int64  `json:"count"`
         Percentage string `json:"percentage"` // "58.3%"
     }

     type AnalyticsSummaryResponse struct {
         ShortCode      string              `json:"short_code"`
         TotalClicks    int64               `json:"total_clicks"`
         Countries      []BreakdownResponse `json:"countries"`
         DeviceTypes    []BreakdownResponse `json:"device_types"`
         TrafficSources []BreakdownResponse `json:"traffic_sources"`
     }

     type ClickDetailResponse struct {
         ShortCode     string `json:"short_code"`
         ClickedAt     int64  `json:"clicked_at"`
         CountryCode   string `json:"country_code"`
         DeviceType    string `json:"device_type"`
         TrafficSource string `json:"traffic_source"`
     }

     type PaginatedClicksResponse struct {
         Clicks     []ClickDetailResponse `json:"clicks"`
         NextCursor string                `json:"next_cursor,omitempty"`
         HasMore    bool                  `json:"has_more"`
     }
     ```
   - Add import `"fmt"` if needed for Sprintf.

2. **Update `internal/analytics/delivery/http/handler.go`**:
   - Keep existing `GetClickCount` handler unchanged (backward compat for `GET /analytics/{code}`).

   - **Update `HandleClickEvent`:** Change `h.analyticsService.RecordClick(r.Context(), event)` to `h.analyticsService.RecordEnrichedClick(r.Context(), event)`. The extended ClickEvent now carries ClientIP, UserAgent, Referer which the service will use for enrichment.

   - **Add `GetAnalyticsSummary` handler** for `GET /analytics/{code}/summary`:
     - Extract `code` from URL param
     - Parse `?from=YYYY-MM-DD` and `?to=YYYY-MM-DD` query params:
       - If `from` provided: parse with `time.Parse("2006-01-02", fromStr)`, convert to Unix timestamp. If parse error, return 400 with Problem Details ("Invalid from date format. Expected YYYY-MM-DD").
       - If `from` not provided: use `0` (beginning of time)
       - If `to` provided: parse with `time.Parse("2006-01-02", toStr)`, add `24*time.Hour - time.Second` to include entire end date, convert to Unix. If parse error, return 400.
       - If `to` not provided: use `time.Now().Unix()` (current time)
     - Call `h.analyticsService.GetAnalyticsSummary(ctx, code, fromUnix, toUnix)`
     - Convert `AnalyticsSummaryResult` to `AnalyticsSummaryResponse`:
       - Map each `BreakdownItem` to `BreakdownResponse`, formatting percentage as `fmt.Sprintf("%.1f%%", item.Percentage)` (e.g., "58.3%")
     - Return 200 with JSON response
     - On error, return 500 with Problem Details

   - **Add `GetClickDetails` handler** for `GET /analytics/{code}/clicks`:
     - Extract `code` from URL param
     - Parse `?cursor=...` query param:
       - If present: base64-decode and parse as int64 timestamp
       - If absent: use `math.MaxInt64` (start from newest)
       - If decode/parse error: return 400 with Problem Details
     - Parse `?limit=...` query param:
       - If present: parse as int, clamp to 1-100
       - If absent: default to 20
     - Call `h.analyticsService.GetClickDetails(ctx, code, cursorTimestamp, limit)`
     - Convert to `PaginatedClicksResponse`
     - Return 200 with JSON response
   - Add imports: `"encoding/base64"`, `"math"`, `"strconv"`, `"fmt"`, `"time"`

3. **Update `internal/analytics/delivery/http/router.go`** — add new routes:
   - Add `r.Get("/analytics/{code}/summary", handler.GetAnalyticsSummary)`
   - Add `r.Get("/analytics/{code}/clicks", handler.GetClickDetails)`
   - Keep existing routes: `/dapr/subscribe`, `/events/click`, `/analytics/{code}`

4. **Update `cmd/analytics-service/main.go`** — wire enrichment services:
   - Import enrichment package: `"go-shortener/internal/analytics/enrichment"`
   - Add env var for GeoIP database path: `geoipDBPath := getEnv("GEOIP_DB_PATH", "data/GeoLite2-Country.mmdb")`
   - Initialize GeoIP resolver:
     ```go
     geoIPResolver, err := enrichment.NewGeoIPResolver(geoipDBPath)
     if err != nil {
         logger.Warn("GeoIP database not available, country resolution disabled", zap.Error(err))
         geoIPResolver = nil
     }
     if geoIPResolver != nil {
         defer geoIPResolver.Close()
     }
     ```
   - Initialize device detector: `deviceDetector := enrichment.NewDeviceDetector()`
   - Initialize referer classifier: `refererClassifier := enrichment.NewRefererClassifier()`
   - **Handle nil GeoIP gracefully:** The AnalyticsService needs a GeoIPResolver interface. Create a fallback `unknownResolver` that always returns "Unknown" when GeoIP database is not available. Define it in main.go or in the enrichment package:
     ```go
     // In main.go or enrichment package
     type fallbackGeoIPResolver struct{}
     func (f *fallbackGeoIPResolver) ResolveCountry(ip string) string { return "Unknown" }
     ```
     Use the fallback when geoIPResolver is nil.
   - Update service construction:
     ```go
     var geoIP usecase.GeoIPResolver
     if geoIPResolver != nil {
         geoIP = geoIPResolver
     } else {
         geoIP = &fallbackGeoIPResolver{}
     }
     service := usecase.NewAnalyticsService(repo, geoIP, deviceDetector, refererClassifier)
     ```
   - Log GeoIP database path on successful load.
  </action>
  <verify>
    Run `go build ./...` — entire project compiles.
    Run `go vet ./...` — no issues.
    Grep for `GetAnalyticsSummary` in handler.go and router.go.
    Grep for `GetClickDetails` in handler.go and router.go.
    Grep for `RecordEnrichedClick` in handler.go.
    Grep for `NewGeoIPResolver` in main.go.
    Grep for `/analytics/{code}/summary` in router.go.
    Grep for `/analytics/{code}/clicks` in router.go.
  </verify>
  <done>Analytics Service enriches clicks at ingest (GeoIP + UA + Referer), serves summary endpoint with country/device/source breakdowns and percentages, serves detail endpoint with cursor pagination, supports time-range filtering on both endpoints, and gracefully handles missing GeoIP database.</done>
</task>

</tasks>

<verification>
1. `go build ./...` — all packages compile
2. `go vet ./...` — no issues
3. GET /analytics/{code}/summary returns JSON with total_clicks, countries[], device_types[], traffic_sources[] each with value/count/percentage
4. GET /analytics/{code}/clicks returns JSON with clicks[], next_cursor, has_more
5. Both endpoints accept ?from=YYYY-MM-DD&to=YYYY-MM-DD
6. HandleClickEvent calls RecordEnrichedClick which enriches before storage
7. GeoIP database failure at startup doesn't crash service (fallback to "Unknown")
8. Enrichment services injected via interfaces (testable)
</verification>

<success_criteria>
- Analytics API returns country-level geo-location from IP address (ANLT-04)
- Analytics API returns device type from User-Agent (ANLT-05)
- Analytics API returns traffic source from Referer header (ANLT-06)
- All enrichment happens in Analytics Service (redirect path stays fast)
- Summary endpoint shows counts + percentages per user decision
- Detail endpoint uses cursor-based pagination per user decision
- Time-range filtering works with arbitrary start/end dates per user decision
- Missing GeoIP database degrades gracefully
- Entire project compiles and all services can start
</success_criteria>

<output>
After completion, create `.planning/phases/03-enhanced-analytics/03-03-SUMMARY.md`
</output>
