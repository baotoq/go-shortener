---
phase: 03-enhanced-analytics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/analytics/database/migrations/000002_add_enrichment_columns.up.sql
  - internal/analytics/database/migrations/000002_add_enrichment_columns.down.sql
  - db/analytics_schema.sql
  - db/analytics_query.sql
  - internal/analytics/repository/sqlite/sqlc/db.go
  - internal/analytics/repository/sqlite/sqlc/models.go
  - internal/analytics/repository/sqlite/sqlc/querier.go
  - internal/analytics/repository/sqlite/sqlc/query.sql.go
  - internal/analytics/repository/sqlite/click_repository.go
  - internal/analytics/usecase/click_repository.go
autonomous: true

must_haves:
  truths:
    - "Clicks table has country_code, device_type, and traffic_source columns"
    - "InsertClick stores enriched fields alongside short_code and clicked_at"
    - "Repository can count clicks grouped by country, device type, and traffic source within a time range"
    - "Repository can fetch individual click details with cursor-based pagination"
    - "Repository can count total clicks within a time range"
  artifacts:
    - path: "internal/analytics/database/migrations/000002_add_enrichment_columns.up.sql"
      provides: "Schema migration adding enrichment columns and indexes"
      contains: "country_code"
    - path: "db/analytics_query.sql"
      provides: "sqlc queries for enriched analytics"
      contains: "CountByCountryInRange"
    - path: "internal/analytics/repository/sqlite/click_repository.go"
      provides: "Repository methods for enriched click data"
      contains: "GetClickDetails"
    - path: "internal/analytics/usecase/click_repository.go"
      provides: "Updated repository interface with enrichment methods"
      contains: "CountByCountryInRange"
  key_links:
    - from: "internal/analytics/repository/sqlite/click_repository.go"
      to: "internal/analytics/repository/sqlite/sqlc/query.sql.go"
      via: "sqlc-generated query methods"
      pattern: "queries\\."
    - from: "internal/analytics/repository/sqlite/click_repository.go"
      to: "internal/analytics/usecase/click_repository.go"
      via: "interface implementation"
      pattern: "var _ usecase\\.ClickRepository"
---

<objective>
Extend the analytics database schema with enrichment columns and create all data access methods needed for enriched click storage and querying.

Purpose: The enrichment data (country, device type, traffic source) needs to be persisted alongside each click and queryable for both aggregated summaries and individual click detail views. This plan builds the complete data layer that Plan 03 will wire to the enrichment services and HTTP handlers.

Output: Database migration, updated sqlc queries and generated code, extended repository with methods for enriched insert, grouped counts, and cursor-paginated detail queries.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-enhanced-analytics/03-RESEARCH.md
@.planning/phases/03-enhanced-analytics/03-CONTEXT.md
@.planning/phases/02-event-driven-analytics/02-03-SUMMARY.md
@internal/analytics/database/migrations/000001_create_clicks.up.sql
@db/analytics_schema.sql
@db/analytics_query.sql
@internal/analytics/repository/sqlite/click_repository.go
@internal/analytics/usecase/click_repository.go
@sqlc.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database migration and update sqlc schema/queries</name>
  <files>
    internal/analytics/database/migrations/000002_add_enrichment_columns.up.sql
    internal/analytics/database/migrations/000002_add_enrichment_columns.down.sql
    db/analytics_schema.sql
    db/analytics_query.sql
  </files>
  <action>
1. **Create migration `internal/analytics/database/migrations/000002_add_enrichment_columns.up.sql`:**
   ```sql
   ALTER TABLE clicks ADD COLUMN country_code TEXT NOT NULL DEFAULT 'Unknown';
   ALTER TABLE clicks ADD COLUMN device_type TEXT NOT NULL DEFAULT 'Unknown';
   ALTER TABLE clicks ADD COLUMN traffic_source TEXT NOT NULL DEFAULT 'Direct';

   CREATE INDEX idx_clicks_time_range ON clicks(short_code, clicked_at);
   CREATE INDEX idx_clicks_country ON clicks(short_code, country_code);
   CREATE INDEX idx_clicks_device ON clicks(short_code, device_type);
   CREATE INDEX idx_clicks_source ON clicks(short_code, traffic_source);
   CREATE INDEX idx_clicks_summary ON clicks(short_code, clicked_at, country_code, device_type, traffic_source);
   ```
   Note: DEFAULT values ensure existing Phase 2 click records migrate cleanly. The idx_clicks_short_code index from migration 000001 is now redundant (covered by composite indexes) but leave it — dropping indexes in SQLite ALTER is cumbersome.

2. **Create down migration `internal/analytics/database/migrations/000002_add_enrichment_columns.down.sql`:**
   - SQLite doesn't support DROP COLUMN in older versions. Since we use modernc.org/sqlite (which supports SQLite 3.35+), we CAN use ALTER TABLE DROP COLUMN.
   ```sql
   DROP INDEX IF EXISTS idx_clicks_summary;
   DROP INDEX IF EXISTS idx_clicks_source;
   DROP INDEX IF EXISTS idx_clicks_device;
   DROP INDEX IF EXISTS idx_clicks_country;
   DROP INDEX IF EXISTS idx_clicks_time_range;

   ALTER TABLE clicks DROP COLUMN traffic_source;
   ALTER TABLE clicks DROP COLUMN device_type;
   ALTER TABLE clicks DROP COLUMN country_code;
   ```

3. **Update `db/analytics_schema.sql`** (sqlc schema — must reflect final table state):
   Replace entire file with:
   ```sql
   CREATE TABLE clicks (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       short_code TEXT NOT NULL,
       clicked_at INTEGER NOT NULL,
       country_code TEXT NOT NULL,
       device_type TEXT NOT NULL,
       traffic_source TEXT NOT NULL
   );
   ```

4. **Update `db/analytics_query.sql`** (sqlc queries):
   Replace entire file with these named queries:
   ```sql
   -- name: InsertEnrichedClick :exec
   INSERT INTO clicks (short_code, clicked_at, country_code, device_type, traffic_source)
   VALUES (?, ?, ?, ?, ?);

   -- name: CountClicksInRange :one
   SELECT COUNT(*) as total FROM clicks
   WHERE short_code = ? AND clicked_at >= ? AND clicked_at <= ?;

   -- name: CountByCountryInRange :many
   SELECT country_code, COUNT(*) as count FROM clicks
   WHERE short_code = ? AND clicked_at >= ? AND clicked_at <= ?
   GROUP BY country_code ORDER BY count DESC;

   -- name: CountByDeviceInRange :many
   SELECT device_type, COUNT(*) as count FROM clicks
   WHERE short_code = ? AND clicked_at >= ? AND clicked_at <= ?
   GROUP BY device_type ORDER BY count DESC;

   -- name: CountBySourceInRange :many
   SELECT traffic_source, COUNT(*) as count FROM clicks
   WHERE short_code = ? AND clicked_at >= ? AND clicked_at <= ?
   GROUP BY traffic_source ORDER BY count DESC;

   -- name: GetClickDetails :many
   SELECT id, short_code, clicked_at, country_code, device_type, traffic_source
   FROM clicks
   WHERE short_code = ? AND clicked_at < ?
   ORDER BY clicked_at DESC
   LIMIT ?;

   -- name: CountClicksByShortCode :one
   SELECT COUNT(*) as total_clicks FROM clicks WHERE short_code = ?;
   ```
   Note: Keep `CountClicksByShortCode` for backward compatibility with existing GetClickCount handler. The `GetClickDetails` query uses `clicked_at < ?` for cursor pagination (pass max int64 for first page). Fetch limit+1 in repository layer to detect hasMore.

5. **Regenerate sqlc code:**
   ```bash
   cd /Users/baotoq/Work/go-shortener && sqlc generate
   ```
  </action>
  <verify>
    Run `sqlc generate` — must succeed with no errors.
    Verify generated files exist: `ls internal/analytics/repository/sqlite/sqlc/query.sql.go`
    Grep for `InsertEnrichedClick` in generated code.
    Grep for `CountByCountryInRange` in generated code.
    Grep for `GetClickDetails` in generated code.
  </verify>
  <done>Database migration adds country_code, device_type, traffic_source columns with indexes. sqlc queries cover enriched insert, time-range grouped counts (by country, device, source), and cursor-paginated click details. Generated Go code reflects all queries.</done>
</task>

<task type="auto">
  <name>Task 2: Update ClickRepository interface and implementation</name>
  <files>
    internal/analytics/usecase/click_repository.go
    internal/analytics/repository/sqlite/click_repository.go
  </files>
  <action>
1. **Update `internal/analytics/usecase/click_repository.go`** — extend the interface:
   ```go
   package usecase

   import "context"

   // ClickDetail represents an individual click record with enrichment data.
   type ClickDetail struct {
       ID            int64
       ShortCode     string
       ClickedAt     int64
       CountryCode   string
       DeviceType    string
       TrafficSource string
   }

   // GroupCount represents a count for a single group value (country, device, source).
   type GroupCount struct {
       Value string
       Count int64
   }

   // PaginatedClicks holds a page of click details with cursor info.
   type PaginatedClicks struct {
       Clicks     []ClickDetail
       NextCursor string
       HasMore    bool
   }

   type ClickRepository interface {
       // InsertClick stores a click with enrichment data.
       InsertClick(ctx context.Context, shortCode string, clickedAt int64, countryCode string, deviceType string, trafficSource string) error
       // CountByShortCode returns total clicks for a short code (backward compat).
       CountByShortCode(ctx context.Context, shortCode string) (int64, error)
       // CountInRange returns total clicks within a time range.
       CountInRange(ctx context.Context, shortCode string, from int64, to int64) (int64, error)
       // CountByCountryInRange returns click counts grouped by country within a time range.
       CountByCountryInRange(ctx context.Context, shortCode string, from int64, to int64) ([]GroupCount, error)
       // CountByDeviceInRange returns click counts grouped by device type within a time range.
       CountByDeviceInRange(ctx context.Context, shortCode string, from int64, to int64) ([]GroupCount, error)
       // CountBySourceInRange returns click counts grouped by traffic source within a time range.
       CountBySourceInRange(ctx context.Context, shortCode string, from int64, to int64) ([]GroupCount, error)
       // GetClickDetails returns paginated individual click records.
       GetClickDetails(ctx context.Context, shortCode string, cursorTimestamp int64, limit int) (*PaginatedClicks, error)
   }
   ```

2. **Update `internal/analytics/repository/sqlite/click_repository.go`** — implement new methods:
   - **Update `InsertClick`:** Change signature to accept `countryCode`, `deviceType`, `trafficSource` params. Use `queries.InsertEnrichedClick` with the corresponding sqlc params struct.
   - **Add `CountInRange`:** Call `queries.CountClicksInRange` with shortCode, from, to. Return the count.
   - **Add `CountByCountryInRange`:** Call `queries.CountByCountryInRange`. Map results to `[]usecase.GroupCount` (Value = row.CountryCode, Count = row.Count).
   - **Add `CountByDeviceInRange`:** Call `queries.CountByDeviceInRange`. Map results to `[]usecase.GroupCount`.
   - **Add `CountBySourceInRange`:** Call `queries.CountBySourceInRange`. Map results to `[]usecase.GroupCount`.
   - **Add `GetClickDetails`:** Call `queries.GetClickDetails` with shortCode, cursorTimestamp, limit+1 (fetch one extra to detect hasMore). Map results to `[]usecase.ClickDetail`. If len > limit, set hasMore=true, trim to limit, generate nextCursor as base64-encoded string of last record's ClickedAt. Return `*usecase.PaginatedClicks`.
   - Import: `"encoding/base64"`, `"strconv"`, `"math"`
   - Keep existing `CountByShortCode` method unchanged.
   - Ensure compile-time interface check: `var _ usecase.ClickRepository = (*ClickRepository)(nil)`
  </action>
  <verify>
    Run `go build ./internal/analytics/...` — must compile.
    Run `go vet ./internal/analytics/...` — no issues.
    Run `go build ./...` — entire project compiles (note: analytics_service.go will need updating in Plan 03 to match new InsertClick signature, but it should still compile if we keep the old InsertClick signature... Actually, the interface change will break AnalyticsService).

    **Important:** The InsertClick signature change will cause a compile error in analytics_service.go (which calls `s.repo.InsertClick(ctx, event.ShortCode, event.Timestamp.Unix())`). To keep this plan self-contained, update the `RecordClick` method in `analytics_service.go` to pass empty strings for the three new fields: `s.repo.InsertClick(ctx, event.ShortCode, event.Timestamp.Unix(), "", "", "")`. This is a temporary bridge until Plan 03 wires enrichment. Add a `// TODO(03-03): wire enrichment services` comment.

    After the temporary fix: `go build ./...` — entire project compiles.
  </verify>
  <done>ClickRepository interface extended with enrichment insert, time-range counts (total, by country, by device, by source), and cursor-paginated detail queries. SQLite implementation maps all sqlc-generated queries. Project compiles end-to-end.</done>
</task>

</tasks>

<verification>
1. `go build ./...` — all packages compile
2. `go vet ./...` — no issues
3. Migration file adds three columns with NOT NULL and default values
4. sqlc generates successfully with all new queries
5. ClickRepository interface has 7 methods (InsertClick, CountByShortCode, CountInRange, CountByCountryInRange, CountByDeviceInRange, CountBySourceInRange, GetClickDetails)
6. Repository implementation maps all sqlc queries correctly
7. Cursor pagination uses base64-encoded timestamp and fetches limit+1 for hasMore detection
</verification>

<success_criteria>
- Migration adds country_code, device_type, traffic_source columns with proper defaults
- Indexes created for all GROUP BY and time-range query patterns
- sqlc generates without errors
- Repository implements all 7 interface methods
- Cursor-based pagination works with base64-encoded timestamps
- Project compiles with temporary bridge in analytics_service.go
</success_criteria>

<output>
After completion, create `.planning/phases/03-enhanced-analytics/03-02-SUMMARY.md`
</output>
