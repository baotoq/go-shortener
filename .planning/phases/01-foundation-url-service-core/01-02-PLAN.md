---
phase: 01-foundation-url-service-core
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/domain/url.go
  - internal/domain/errors.go
  - internal/usecase/url_service.go
  - internal/usecase/url_repository.go
  - internal/repository/sqlite/url_repository.go
autonomous: true

must_haves:
  truths:
    - "URL service validates input URLs (scheme, host, length) and returns typed errors"
    - "URL service generates 8-char NanoID short codes with collision retry (up to 5 attempts)"
    - "URL service deduplicates: submitting same URL returns existing short code"
    - "Repository stores and retrieves URLs from SQLite via sqlc-generated code"
    - "Service depends on repository interface, not concrete implementation (dependency inversion)"
  artifacts:
    - path: "internal/domain/url.go"
      provides: "URL domain entity"
      contains: "type URL struct"
    - path: "internal/domain/errors.go"
      provides: "Domain-specific error types"
      contains: "ErrURLNotFound"
    - path: "internal/usecase/url_service.go"
      provides: "Business logic for URL shortening"
      contains: "func.*CreateShortURL"
    - path: "internal/usecase/url_repository.go"
      provides: "Repository interface (dependency inversion)"
      contains: "type URLRepository interface"
    - path: "internal/repository/sqlite/url_repository.go"
      provides: "SQLite repository implementation using sqlc"
      contains: "func NewURLRepository"
  key_links:
    - from: "internal/usecase/url_service.go"
      to: "internal/usecase/url_repository.go"
      via: "interface dependency"
      pattern: "URLRepository"
    - from: "internal/repository/sqlite/url_repository.go"
      to: "internal/repository/sqlite/sqlc/query.sql.go"
      via: "sqlc queries"
      pattern: "sqlc\\.Queries"
    - from: "internal/usecase/url_service.go"
      to: "internal/domain/url.go"
      via: "domain entity usage"
      pattern: "domain\\.URL"
---

<objective>
Implement the domain entities, repository interface + SQLite implementation, and URL service with all business logic (validation, NanoID generation, deduplication, collision retry).

Purpose: Build the core business logic layer with clean architecture dependency inversion -- the service depends on a repository interface, and the SQLite implementation satisfies that interface using sqlc-generated code.
Output: Fully functional domain + usecase + repository layers that can be wired to any transport (HTTP in Plan 03).
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-url-service-core/01-RESEARCH.md
@.planning/phases/01-foundation-url-service-core/01-CONTEXT.md
@.planning/phases/01-foundation-url-service-core/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain entities and repository interface</name>
  <files>
    internal/domain/url.go
    internal/domain/errors.go
    internal/usecase/url_repository.go
  </files>
  <action>
1. Create `internal/domain/url.go` with the URL entity:
   ```go
   package domain

   import "time"

   type URL struct {
       ID          int64     `json:"id"`
       ShortCode   string    `json:"short_code"`
       OriginalURL string    `json:"original_url"`
       CreatedAt   time.Time `json:"created_at"`
   }
   ```

2. Create `internal/domain/errors.go` with domain-specific sentinel errors:
   ```go
   package domain

   import "errors"

   var (
       ErrURLNotFound       = errors.New("url not found")
       ErrInvalidURL        = errors.New("invalid url")
       ErrShortCodeConflict = errors.New("short code generation failed after max retries")
   )
   ```
   Use `errors.New` for sentinel errors. These are matched with `errors.Is()` in the HTTP layer to determine status codes.

3. Create `internal/usecase/url_repository.go` with the repository interface:
   ```go
   package usecase

   import (
       "context"
       "go-shortener/internal/domain"
   )

   type URLRepository interface {
       Save(ctx context.Context, shortCode, originalURL string) (*domain.URL, error)
       FindByShortCode(ctx context.Context, code string) (*domain.URL, error)
       FindByOriginalURL(ctx context.Context, originalURL string) (*domain.URL, error)
   }
   ```

   IMPORTANT: The interface is defined in the usecase package (not repository) -- this is dependency inversion. The repository package imports usecase to implement the interface.

   Note: `Save` takes primitive strings (not domain.URL) because the caller provides shortCode + originalURL, and the repository returns the full entity with ID and CreatedAt populated by the database.
  </action>
  <verify>
    - `go build ./internal/domain/` compiles
    - `go build ./internal/usecase/` compiles (may need a temporary import or build tag)
    - `internal/domain/url.go` has URL struct with ID, ShortCode, OriginalURL, CreatedAt fields
    - `internal/domain/errors.go` has ErrURLNotFound, ErrInvalidURL, ErrShortCodeConflict
    - `internal/usecase/url_repository.go` has URLRepository interface with Save, FindByShortCode, FindByOriginalURL
  </verify>
  <done>Domain entity URL defined, sentinel errors created, URLRepository interface defined in usecase package (dependency inversion)</done>
</task>

<task type="auto">
  <name>Task 2: Implement SQLite repository and URL service with business logic</name>
  <files>
    internal/repository/sqlite/url_repository.go
    internal/usecase/url_service.go
  </files>
  <action>
1. Create `internal/repository/sqlite/url_repository.go`:
   - Struct holding `*sqlc.Queries` (from generated code)
   - Constructor `NewURLRepository(db *sql.DB) *URLRepository`
   - Implement all three methods from `usecase.URLRepository` interface:
     - `Save`: calls `queries.CreateURL`, converts sqlc model to domain.URL
     - `FindByShortCode`: calls `queries.FindByShortCode`, returns domain.URL or `domain.ErrURLNotFound` if not found (wrap sql.ErrNoRows)
     - `FindByOriginalURL`: calls `queries.FindByOriginalURL`, returns domain.URL or `domain.ErrURLNotFound` if not found
   - Handle `sql.ErrNoRows` by returning `domain.ErrURLNotFound` (use `errors.Is`)
   - Parse `created_at` from SQLite TEXT format to time.Time if needed by sqlc output

2. Create `internal/usecase/url_service.go`:
   - Struct `URLService` with `repo URLRepository` field
   - Constructor `NewURLService(repo URLRepository) *URLService`

   **CreateShortURL(ctx context.Context, originalURL string) (*domain.URL, error):**
   - Validate URL using `validateURL()` helper (see below). If invalid, return wrapped `domain.ErrInvalidURL`
   - Check for duplicate: call `repo.FindByOriginalURL(ctx, originalURL)`. If found, return existing URL (dedup per user decision)
   - If not found (errors.Is domain.ErrURLNotFound), generate short code with collision retry:
     - Loop up to 5 times (maxRetries = 5)
     - Generate 8-char NanoID using `gonanoid.Generate(alphabet, 8)` with alphabet `"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"`
     - Call `repo.Save(ctx, code, originalURL)`
     - If save succeeds, return the URL
     - If save fails due to unique constraint violation (short_code collision), retry
     - After 5 failures, return `domain.ErrShortCodeConflict`
   - Check `ctx.Err()` between retries to respect context cancellation

   **GetByShortCode(ctx context.Context, code string) (*domain.URL, error):**
   - Call `repo.FindByShortCode(ctx, code)`
   - Return result directly (repository already wraps ErrNoRows as ErrURLNotFound)

   **validateURL(rawURL string) error:**
   - Check length <= 2048 chars. If exceeded, return error with detail
   - Parse with `url.ParseRequestURI(rawURL)`. If fails, return error
   - Check scheme is "http" or "https" (case-insensitive). If not, return error
   - Check host is not empty. If empty, return error
   - Allow localhost and private IPs (no restriction per user decision)

   Important: Do NOT use moogar0880/problems or any RFC 7807 library in this layer. The service layer returns domain errors. The HTTP layer (Plan 03) translates them to RFC 7807 responses.
  </action>
  <verify>
    - `go build ./internal/repository/sqlite/` compiles
    - `go build ./internal/usecase/` compiles
    - `go vet ./internal/...` passes with no issues
    - URLRepository implementation satisfies the interface (compiler enforces this via return type)
    - URLService has CreateShortURL and GetByShortCode methods
    - validateURL rejects: empty string, no scheme, ftp:// scheme, URLs > 2048 chars, missing host
    - validateURL accepts: http://example.com, https://example.com, http://localhost:3000, https://192.168.1.1/path
  </verify>
  <done>SQLite repository implements URLRepository interface using sqlc. URLService implements URL shortening with validation (http/https, max 2048 chars, host required), NanoID generation (8 chars, 62-char alphabet), dedup (same URL returns same code), and collision retry (5 attempts). Clean dependency inversion: service depends on interface, not concrete repo.</done>
</task>

</tasks>

<verification>
1. `go build ./internal/...` compiles all internal packages
2. `go vet ./internal/...` passes
3. URLService.CreateShortURL validates, deduplicates, generates NanoID, retries on collision
4. URLService.GetByShortCode returns domain.URL or domain.ErrURLNotFound
5. SQLite repository maps between sqlc generated types and domain types
6. No HTTP/transport concerns leak into domain or usecase layers
</verification>

<success_criteria>
- Domain entity URL with ID, ShortCode, OriginalURL, CreatedAt
- Sentinel errors: ErrURLNotFound, ErrInvalidURL, ErrShortCodeConflict
- URLRepository interface in usecase package (dependency inversion)
- SQLite implementation using sqlc-generated queries
- URLService with CreateShortURL (validate, dedup, nanoid, retry) and GetByShortCode
- URL validation: http/https only, host required, max 2048 chars, localhost allowed
- All packages compile and pass go vet
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-url-service-core/01-02-SUMMARY.md`
</output>
