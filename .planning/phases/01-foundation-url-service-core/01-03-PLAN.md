---
phase: 01-foundation-url-service-core
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - internal/delivery/http/handler.go
  - internal/delivery/http/router.go
  - internal/delivery/http/middleware.go
  - internal/delivery/http/response.go
  - pkg/problemdetails/problemdetails.go
  - internal/database/database.go
  - cmd/url-service/main.go
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/urls accepts JSON body with original_url and returns 201 with short_code, short_url, original_url"
    - "GET /:code redirects (302) to the original URL"
    - "GET /:code returns 404 RFC 7807 error for non-existent short codes"
    - "POST /api/v1/urls returns 400 RFC 7807 error for invalid URLs"
    - "Rate limiter returns 429 with RFC 7807 error and rate limit headers when exceeded"
    - "Application starts, runs migrations, and serves HTTP on configured port"
  artifacts:
    - path: "internal/delivery/http/handler.go"
      provides: "HTTP handlers for URL operations"
      contains: "func.*CreateShortURL"
    - path: "internal/delivery/http/router.go"
      provides: "Chi router with middleware chain and route definitions"
      contains: "chi.NewRouter"
    - path: "internal/delivery/http/middleware.go"
      provides: "Rate limiting middleware with per-IP tracking and cleanup"
      contains: "RateLimiter"
    - path: "internal/delivery/http/response.go"
      provides: "JSON and error response helpers"
      contains: "writeJSON"
    - path: "pkg/problemdetails/problemdetails.go"
      provides: "RFC 7807 Problem Details type and constructor"
      contains: "ProblemDetail"
    - path: "cmd/url-service/main.go"
      provides: "Application entry point wiring all layers together"
      contains: "func main"
  key_links:
    - from: "internal/delivery/http/handler.go"
      to: "internal/usecase/url_service.go"
      via: "service injection"
      pattern: "usecase\\.URLService"
    - from: "internal/delivery/http/router.go"
      to: "internal/delivery/http/handler.go"
      via: "route registration"
      pattern: "handler\\."
    - from: "internal/delivery/http/handler.go"
      to: "pkg/problemdetails/problemdetails.go"
      via: "error response formatting"
      pattern: "problemdetails\\."
    - from: "cmd/url-service/main.go"
      to: "internal/delivery/http/router.go"
      via: "server startup"
      pattern: "NewRouter"
    - from: "cmd/url-service/main.go"
      to: "internal/repository/sqlite/url_repository.go"
      via: "dependency wiring"
      pattern: "sqlite\\.NewURLRepository"
---

<objective>
Build the HTTP delivery layer with Chi router, handlers, rate limiting middleware, structured logging, RFC 7807 error responses, and wire everything together in main.go with database initialization and migration execution.

Purpose: Complete the vertical slice -- users can now shorten URLs and be redirected via HTTP API. This is the final plan that makes the application runnable end-to-end.
Output: Fully functional URL shortener API that starts, migrates the database, and serves all endpoints.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-url-service-core/01-RESEARCH.md
@.planning/phases/01-foundation-url-service-core/01-CONTEXT.md
@.planning/phases/01-foundation-url-service-core/01-01-SUMMARY.md
@.planning/phases/01-foundation-url-service-core/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RFC 7807 helpers, response utilities, and HTTP handlers</name>
  <files>
    pkg/problemdetails/problemdetails.go
    internal/delivery/http/response.go
    internal/delivery/http/handler.go
  </files>
  <action>
1. Create `pkg/problemdetails/problemdetails.go`:
   - Define `ProblemDetail` struct with JSON tags:
     ```go
     type ProblemDetail struct {
         Type   string `json:"type"`
         Title  string `json:"title"`
         Status int    `json:"status"`
         Detail string `json:"detail"`
     }
     ```
   - Constructor `New(status int, problemType, title, detail string) *ProblemDetail`
   - The `Type` field format: `"https://api.example.com/problems/" + problemType`
   - Define common problem type constants:
     - `TypeInvalidURL = "invalid-url"`
     - `TypeNotFound = "not-found"`
     - `TypeRateLimitExceeded = "rate-limit-exceeded"`
     - `TypeInternalError = "internal-error"`
     - `TypeInvalidRequest = "invalid-request"`

2. Create `internal/delivery/http/response.go`:
   - `writeJSON(w http.ResponseWriter, status int, data interface{})`: sets Content-Type to application/json, writes status, encodes data
   - `writeProblem(w http.ResponseWriter, problem *problemdetails.ProblemDetail)`: sets Content-Type to application/problem+json, writes problem.Status, encodes problem
   - These are package-level functions (not methods), used by handlers

3. Create `internal/delivery/http/handler.go`:
   - `Handler` struct with `service *usecase.URLService` and `baseURL string` fields
   - Constructor `NewHandler(service *usecase.URLService, baseURL string) *Handler`
   - `baseURL` is used to construct the full short_url in creation response (e.g., "http://localhost:8080")

   **CreateShortURL handler (POST /api/v1/urls):**
   - Parse JSON body: `{"original_url": "https://example.com"}` into request struct
   - If body is empty or malformed JSON, return 400 Problem Detail (type: invalid-request, detail: "Request body must be valid JSON with 'original_url' field")
   - If original_url is missing/empty, return 400 Problem Detail (type: invalid-url, detail: "original_url is required")
   - Call `service.CreateShortURL(ctx, req.OriginalURL)`
   - If error is domain.ErrInvalidURL, return 400 Problem Detail (type: invalid-url, include the error message as detail)
   - If error is domain.ErrShortCodeConflict, return 500 Problem Detail (type: internal-error, detail: "Failed to generate short code")
   - If other error, return 500 Problem Detail (type: internal-error, detail: "Internal server error")
   - On success, return 201 with flat JSON response:
     ```json
     {
       "short_code": "abc12345",
       "short_url": "http://localhost:8080/abc12345",
       "original_url": "https://example.com"
     }
     ```
   - Construct short_url as `baseURL + "/" + shortCode`

   **Redirect handler (GET /{code}):**
   - Extract `{code}` from Chi URL param: `chi.URLParam(r, "code")`
   - Call `service.GetByShortCode(ctx, code)`
   - If error is domain.ErrURLNotFound, return 404 Problem Detail (type: not-found, detail: "Short URL not found: {code}")
   - If other error, return 500 Problem Detail
   - On success, redirect with `http.Redirect(w, r, url.OriginalURL, http.StatusFound)` (302)

   **GetURLDetails handler (GET /api/v1/urls/{code}) [optional convenience endpoint]:**
   - Extract code, call service.GetByShortCode
   - If not found, return 404 Problem Detail
   - On success, return 200 with same flat JSON format (short_code, short_url, original_url)
  </action>
  <verify>
    - `go build ./pkg/problemdetails/` compiles
    - `go build ./internal/delivery/http/` compiles
    - Handler struct has CreateShortURL, Redirect, and GetURLDetails methods
    - ProblemDetail has Type, Title, Status, Detail fields with correct JSON tags
    - Content-Type is "application/json" for success, "application/problem+json" for errors
  </verify>
  <done>RFC 7807 ProblemDetail type with common constants, JSON/error response helpers, and HTTP handlers for POST /api/v1/urls (201 create), GET /{code} (302 redirect), GET /api/v1/urls/{code} (200 details) with proper error mapping (400 invalid URL, 404 not found, 429 rate limit, 500 internal)</done>
</task>

<task type="auto">
  <name>Task 2: Create rate limiter middleware, router, and wire main.go</name>
  <files>
    internal/delivery/http/middleware.go
    internal/delivery/http/router.go
    internal/database/database.go
    cmd/url-service/main.go
  </files>
  <action>
1. Create `internal/delivery/http/middleware.go`:
   **RateLimiter struct:**
   - Fields: `limiters map[string]*entry`, `mu sync.RWMutex`, `rateLimit rate.Limit`, `burst int`
   - `entry` struct: `limiter *rate.Limiter`, `lastSeen time.Time`
   - Constructor `NewRateLimiter(requestsPerMinute int) *RateLimiter` — creates limiter with rate = `rate.Every(time.Minute / time.Duration(requestsPerMinute))`, burst = requestsPerMinute
   - `getLimiter(ip string) *rate.Limiter` — returns existing or creates new limiter for IP, updates lastSeen
   - `Middleware(next http.Handler) http.Handler`:
     - Get client IP from `r.RemoteAddr` (RealIP middleware runs before this, so RemoteAddr has the real IP)
     - Get or create limiter for this IP
     - If `!limiter.Allow()`:
       - Set headers: `X-RateLimit-Limit` (burst), `X-RateLimit-Remaining` ("0"), `X-RateLimit-Reset` (unix timestamp of now + 1 minute)
       - Write 429 RFC 7807 Problem Detail (type: rate-limit-exceeded, title: "Rate Limit Exceeded", detail: "Too many requests. Please try again later.")
       - Return (do not call next)
     - If allowed:
       - Set headers: `X-RateLimit-Limit` (burst), `X-RateLimit-Remaining` (estimated from `int(limiter.Tokens())`)
       - Call `next.ServeHTTP(w, r)`
   - `StartCleanup()` — launch goroutine with ticker every 10 minutes, delete entries where `time.Since(e.lastSeen) > 1 hour`
   - Call `StartCleanup()` from constructor

   **LoggerMiddleware(logger *zap.Logger) func(http.Handler) http.Handler:**
   - Wrap ResponseWriter using `chi/middleware.NewWrapResponseWriter` to capture status code
   - Log on defer: method, path, status, duration, remote_addr, request_id (from chi middleware.GetReqID)
   - Use `logger.Info("http request", zap.String(...), ...)`

2. Create `internal/delivery/http/router.go`:
   - Function `NewRouter(handler *Handler, logger *zap.Logger, rateLimiter *RateLimiter) http.Handler`
   - Create `chi.NewRouter()`
   - Global middleware chain (order matters):
     1. `middleware.RequestID` — inject request ID
     2. `middleware.RealIP` — extract real IP from X-Forwarded-For
     3. `LoggerMiddleware(logger)` — structured request logging
     4. `middleware.Recoverer` — panic recovery
     5. `rateLimiter.Middleware` — rate limiting (after RealIP so IP is correct)
   - Register redirect route: `r.Get("/{code}", handler.Redirect)`
   - Register API v1 group: `r.Route("/api/v1", func(r chi.Router) { ... })`
     - Within group: `r.Post("/urls", handler.CreateShortURL)`
     - Within group: `r.Get("/urls/{code}", handler.GetURLDetails)`
   - Return router

3. Update `cmd/url-service/main.go` — the full application entry point:
   - Read config from environment variables (with defaults):
     - `PORT` (default: "8080")
     - `DATABASE_PATH` (default: "data/shortener.db")
     - `BASE_URL` (default: "http://localhost:8080")
     - `RATE_LIMIT` (default: "100" — requests per minute)
   - Helper `getEnv(key, defaultValue string) string`
   - Initialize Zap logger (development mode)
   - Open SQLite database:
     ```go
     import _ "modernc.org/sqlite"
     db, err := sql.Open("sqlite", databasePath)
     ```
   - Configure SQLite connection pool: `db.SetMaxOpenConns(1)`, `db.SetMaxIdleConns(1)`, `db.SetConnMaxLifetime(0)`
   - Enable WAL mode: `db.Exec("PRAGMA journal_mode=WAL")`, `db.Exec("PRAGMA busy_timeout=5000")`
   - Run migrations using golang-migrate with embedded FS:
     - Create `internal/database/database.go` with `OpenDB` and `RunMigrations` functions
     - Migration files already exist at `internal/database/migrations/` (created in Plan 01-01)
     - Embed using `//go:embed migrations/*.sql` in `internal/database/database.go`
     - Use `iofs.New(migrationsFS, "migrations")` as source driver
     - Use `sqlite` database driver from golang-migrate
   - Wire dependencies:
     ```go
     repo := sqlite.NewURLRepository(db)
     service := usecase.NewURLService(repo)
     handler := httpdelivery.NewHandler(service, baseURL)
     rateLimiter := httpdelivery.NewRateLimiter(rateLimit)
     router := httpdelivery.NewRouter(handler, logger, rateLimiter)
     ```
   - Ensure data directory exists for SQLite file: `os.MkdirAll(filepath.Dir(databasePath), 0755)`
   - Start HTTP server with graceful shutdown:
     ```go
     srv := &http.Server{
         Addr:    ":" + port,
         Handler: router,
     }
     ```
   - Log startup: `logger.Info("server starting", zap.String("port", port), zap.String("base_url", baseURL))`
   - Listen for OS signals (SIGINT, SIGTERM) for graceful shutdown with context timeout
   - On shutdown: close database, sync logger

   **Additional file:**
   - `internal/database/database.go` — new file for DB initialization + migration helpers
  </action>
  <verify>
    - `go build ./cmd/url-service/` compiles successfully and produces binary
    - Run the binary: `./url-service` starts and logs "server starting" with port
    - Test with curl:
      ```
      # Create URL
      curl -s -X POST http://localhost:8080/api/v1/urls -H 'Content-Type: application/json' -d '{"original_url": "https://example.com"}' | jq .
      # Expected: 201 with short_code, short_url, original_url

      # Redirect
      curl -s -o /dev/null -w "%{http_code} %{redirect_url}" http://localhost:8080/{code}
      # Expected: 302 redirect to https://example.com

      # Not found
      curl -s http://localhost:8080/nonexist | jq .
      # Expected: 404 with RFC 7807 problem detail

      # Invalid URL
      curl -s -X POST http://localhost:8080/api/v1/urls -H 'Content-Type: application/json' -d '{"original_url": "not-a-url"}' | jq .
      # Expected: 400 with RFC 7807 problem detail

      # Duplicate URL (should return same short_code)
      curl -s -X POST http://localhost:8080/api/v1/urls -H 'Content-Type: application/json' -d '{"original_url": "https://example.com"}' | jq .
      # Expected: 201 with SAME short_code as first creation

      # Check rate limit headers
      curl -s -I http://localhost:8080/api/v1/urls -X POST -H 'Content-Type: application/json' -d '{"original_url": "https://test.com"}'
      # Expected: X-RateLimit-Limit and X-RateLimit-Remaining headers present
      ```
    - `go vet ./...` passes
  </verify>
  <done>Rate limiter middleware with per-IP tracking (100 req/min, cleanup every 10 min), structured logging middleware with Zap, Chi router with versioned API routes and root-level redirect, main.go wiring all layers with SQLite + WAL mode + embedded migrations + graceful shutdown. Full end-to-end: POST creates short URL, GET redirects, errors return RFC 7807, rate limit headers on all responses.</done>
</task>

</tasks>

<verification>
1. `go build ./cmd/url-service/` produces working binary
2. Server starts, runs migrations, serves on configured port
3. POST /api/v1/urls with valid URL returns 201 + flat JSON (short_code, short_url, original_url)
4. POST /api/v1/urls with invalid URL returns 400 + RFC 7807 problem detail
5. POST /api/v1/urls with duplicate URL returns same short_code (dedup)
6. GET /{code} with valid code returns 302 redirect
7. GET /{code} with invalid code returns 404 + RFC 7807 problem detail
8. Rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining) present on responses
9. Excessive requests from same IP return 429 + RFC 7807 problem detail
10. Structured JSON logs for each request (method, path, status, duration)
11. Graceful shutdown on SIGINT/SIGTERM
</verification>

<success_criteria>
- All Phase 1 success criteria met:
  1. User submits a long URL via API and receives a short link with auto-generated code
  2. User visiting a short link is redirected (302) to the original URL
  3. API validates URLs and returns clear error messages for invalid input
  4. API returns 404 with meaningful error for non-existent short codes
  5. API rejects excessive requests from same client (rate limiting active)
- Clean architecture layers: handler -> service -> repository (no layer violations)
- RFC 7807 Problem Details for all error responses
- Versioned API: POST /api/v1/urls, GET /api/v1/urls/:code
- Root-level redirect: GET /:code
- Per-IP rate limiting with standard headers
- SQLite with WAL mode, single connection, embedded migrations
- Structured logging with Zap
- Graceful shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-url-service-core/01-03-SUMMARY.md`
</output>
