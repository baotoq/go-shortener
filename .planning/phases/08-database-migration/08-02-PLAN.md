---
phase: 08-database-migration
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - services/url-api/internal/config/config.go
  - services/url-api/internal/svc/servicecontext.go
  - services/url-api/internal/logic/shorten/shortenlogic.go
  - services/url-api/internal/logic/redirect/redirectlogic.go
  - services/url-api/internal/logic/links/listlinkslogic.go
  - services/url-api/internal/logic/links/getlinkdetaillogic.go
  - services/url-api/internal/logic/links/deletelinklogic.go
  - services/url-api/internal/handler/redirect/redirecthandler.go
  - services/url-api/etc/url.yaml
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/urls creates a real short URL with NanoID code stored in PostgreSQL"
    - "GET /:code redirects to the original URL with HTTP 302 and increments click count"
    - "GET /api/v1/links returns paginated list of URLs from PostgreSQL with search support"
    - "GET /api/v1/links/:code returns real link details including click count from database"
    - "DELETE /api/v1/links/:code removes the URL row from PostgreSQL (hard delete)"
  artifacts:
    - path: "services/url-api/internal/config/config.go"
      provides: "Config with DataSource field for PostgreSQL"
      contains: "DataSource"
    - path: "services/url-api/internal/svc/servicecontext.go"
      provides: "ServiceContext with UrlModel dependency"
      contains: "UrlModel"
    - path: "services/url-api/internal/logic/shorten/shortenlogic.go"
      provides: "URL creation with NanoID + UUIDv7 + DB insert"
      contains: "NewV7"
    - path: "services/url-api/internal/logic/redirect/redirectlogic.go"
      provides: "Redirect with DB lookup and click count increment"
      contains: "FindOneByShortCode"
  key_links:
    - from: "services/url-api/internal/svc/servicecontext.go"
      to: "services/url-api/model/urlsmodel.go"
      via: "model.NewUrlsModel(conn)"
      pattern: "NewUrlsModel"
    - from: "services/url-api/internal/logic/shorten/shortenlogic.go"
      to: "services/url-api/model"
      via: "svcCtx.UrlModel.Insert"
      pattern: "UrlModel\\.Insert"
    - from: "services/url-api/internal/logic/redirect/redirectlogic.go"
      to: "services/url-api/internal/handler/redirect/redirecthandler.go"
      via: "HTTP 302 redirect response"
      pattern: "http\\.Redirect"
---

<objective>
Wire URL API service to PostgreSQL by replacing all stub logic with real database operations. Add NanoID short code generation, UUIDv7 primary keys, and HTTP redirect behavior.

Purpose: Transform the URL API from a stub service into a fully functional URL shortener with real persistence.

Output: All 5 URL API endpoints working with PostgreSQL — create, redirect, list, detail, delete.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-database-migration/08-RESEARCH.md
@.planning/phases/08-database-migration/08-CONTEXT.md
@.planning/phases/08-database-migration/08-01-SUMMARY.md
@services/url-api/url.api
@services/url-api/internal/config/config.go
@services/url-api/internal/svc/servicecontext.go
@services/url-api/internal/logic/shorten/shortenlogic.go
@services/url-api/internal/logic/redirect/redirectlogic.go
@services/url-api/internal/logic/links/listlinkslogic.go
@services/url-api/internal/logic/links/getlinkdetaillogic.go
@services/url-api/internal/logic/links/deletelinklogic.go
@services/url-api/model/urlsmodel.go
@services/url-api/model/urlsmodel_gen.go
@pkg/problemdetails/problemdetails.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire PostgreSQL connection and model to ServiceContext</name>
  <files>
    services/url-api/internal/config/config.go
    services/url-api/internal/svc/servicecontext.go
    services/url-api/etc/url.yaml
    go.mod
    go.sum
  </files>
  <action>
    **Step 1: Add DataSource to config.**
    Edit `services/url-api/internal/config/config.go`:
    ```go
    type Config struct {
      rest.RestConf
      BaseUrl    string
      DataSource string
    }
    ```

    **Step 2: Add DataSource to YAML config.**
    Edit `services/url-api/etc/url.yaml` — add:
    ```yaml
    DataSource: postgres://postgres:postgres@localhost:5432/shortener?sslmode=disable
    ```

    **Step 3: Wire model in ServiceContext.**
    Edit `services/url-api/internal/svc/servicecontext.go`:
    ```go
    import (
      "go-shortener/services/url-api/internal/config"
      "go-shortener/services/url-api/model"

      "github.com/zeromicro/go-zero/core/stores/sqlx"
      _ "github.com/lib/pq"
    )

    type ServiceContext struct {
      Config   config.Config
      UrlModel model.UrlsModel
    }

    func NewServiceContext(c config.Config) *ServiceContext {
      conn := sqlx.NewSqlConn("postgres", c.DataSource)
      return &ServiceContext{
        Config:   c,
        UrlModel: model.NewUrlsModel(conn),
      }
    }
    ```
    The `_ "github.com/lib/pq"` blank import registers the PostgreSQL driver.

    **Step 4: Add NanoID dependency.**
    ```bash
    go get github.com/matoous/go-nanoid/v2
    ```

    **Step 5: Verify compilation.**
    ```bash
    go build ./services/url-api/...
    ```
  </action>
  <verify>
    1. `go build ./services/url-api/...` compiles without errors
    2. `grep "DataSource" services/url-api/internal/config/config.go` shows the field
    3. `grep "UrlModel" services/url-api/internal/svc/servicecontext.go` shows the field
    4. `grep "lib/pq" services/url-api/internal/svc/servicecontext.go` shows the driver import
  </verify>
  <done>ServiceContext creates PostgreSQL connection and UrlModel on startup. Config includes DataSource.</done>
</task>

<task type="auto">
  <name>Task 2: Replace all stub logic with real database operations</name>
  <files>
    services/url-api/internal/logic/shorten/shortenlogic.go
    services/url-api/internal/logic/redirect/redirectlogic.go
    services/url-api/internal/logic/links/listlinkslogic.go
    services/url-api/internal/logic/links/getlinkdetaillogic.go
    services/url-api/internal/logic/links/deletelinklogic.go
    services/url-api/internal/handler/redirect/redirecthandler.go
  </files>
  <action>
    **Replace ALL stub logic files with real implementations:**

    **A) Shorten Logic (`shortenlogic.go`):**
    - Generate UUIDv7 for primary key: `id, _ := uuid.NewV7()` (import `github.com/google/uuid`)
    - Generate NanoID short code: `gonanoid.Generate(alphabet, 8)` (import `github.com/matoous/go-nanoid/v2`)
    - Use alphabet: `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz` (62 chars, URL-safe)
    - Insert into database via `l.svcCtx.UrlModel.Insert(ctx, &model.Urls{...})`
    - Collision retry: up to 5 attempts. On unique constraint violation (short_code collision), generate new code and retry.
      Detect collision via error check — `err != nil` after Insert, check for unique_violation.
    - Return ShortenResponse with short_code, short_url (BaseUrl + "/" + code), original_url
    - Handle errors: return Problem Details for validation failures, internal errors

    **B) Redirect Logic (`redirectlogic.go`):**
    - Look up URL by short code: `l.svcCtx.UrlModel.FindOneByShortCode(ctx, req.Code)`
    - If not found (check for `model.ErrNotFound`): return Problem Details 404
    - If found: increment click count asynchronously (goroutine, fire-and-forget):
      `go l.svcCtx.UrlModel.IncrementClickCount(context.Background(), req.Code)`
    - Return the original URL to the handler for HTTP redirect
    - IMPORTANT: The redirect handler needs to perform `http.Redirect(w, r, originalUrl, http.StatusFound)` (302).
      The current handler was generated for a no-response endpoint. It needs customization.

    **Redirect Handler Customization (`redirecthandler.go`):**
    - The generated redirect handler calls logic and returns nothing (DELETE-like pattern).
    - Customize it to: call logic, get the original URL back, perform `http.Redirect(w, r, url, 302)`.
    - The logic function signature may need to change to return the original URL string.
    - Option: Change `Redirect(req) error` to `Redirect(req) (string, error)` where string is the target URL.
      Then handler does: `url, err := l.Redirect(&req); if err != nil { ... }; http.Redirect(w, r, url, http.StatusFound)`.
    - This is safe to edit — handlers are marked "Safe to edit" by goctl, and redirect is a special case that needs HTTP redirect, not JSON response.
    - IMPORTANT: Do not write JSON response for redirect. The handler must use `http.Redirect()` directly.

    **C) ListLinks Logic (`listlinkslogic.go`):**
    - Call `l.svcCtx.UrlModel.ListWithPagination(ctx, page, perPage, search, sort, order)` (or whatever signature was implemented in Plan 01)
    - Map model results to `types.LinkItem` array
    - Calculate total_pages from total_count and per_page
    - Return `LinkListResponse` with links, page, per_page, total_pages, total_count
    - If no results: return empty array (not null), total_count: 0

    **D) GetLinkDetail Logic (`getlinkdetaillogic.go`):**
    - Look up by short code: `l.svcCtx.UrlModel.FindOneByShortCode(ctx, req.Code)`
    - If not found: return Problem Details 404
    - Map to `LinkDetailResponse` with short_code, original_url, created_at (Unix timestamp), total_clicks (from denormalized click_count)

    **E) DeleteLink Logic (`deletelinklogic.go`):**
    - Look up by short code first to get the ID (needed for Delete which takes primary key)
    - If not found: return Problem Details 404
    - Delete: `l.svcCtx.UrlModel.Delete(ctx, id)`
    - Per user decision: hard delete (row removed, not soft delete)
    - Return nil on success (handler returns 200)

    **Error Handling Pattern for all logic:**
    Use `pkg/problemdetails` for structured errors:
    ```go
    import "go-shortener/pkg/problemdetails"

    // Not found:
    return nil, problemdetails.New(404, problemdetails.TypeNotFound, "Not Found", "short code 'xxx' not found")

    // Internal error:
    return nil, problemdetails.New(500, problemdetails.TypeInternalError, "Internal Error", "failed to create short URL")
    ```
    Note: The custom error handler from Phase 7 (httpx.SetErrorHandlerCtx) already handles ProblemDetail errors. Make sure logic returns `*ProblemDetail` errors that the handler can serialize correctly — or return standard errors and let the error handler decide format. Check how the error handler works in url.go main entry point.
  </action>
  <verify>
    1. `go build ./services/url-api/...` compiles
    2. Start PostgreSQL: `docker compose up -d postgres`
    3. Start URL API: `go run services/url-api/url.go -f services/url-api/etc/url.yaml`
    4. **Shorten:** `curl -s -X POST http://localhost:8080/api/v1/urls -H 'Content-Type: application/json' -d '{"original_url":"https://example.com"}' | jq .`
       - Returns JSON with real short_code (8 chars), short_url, original_url
    5. **Redirect:** `curl -s -o /dev/null -w "%{http_code} %{redirect_url}" http://localhost:8080/{short_code}`
       - Returns HTTP 302 with Location header pointing to original URL
    6. **List:** `curl -s http://localhost:8080/api/v1/links | jq .`
       - Returns JSON with links array containing the created URL, total_count >= 1
    7. **Detail:** `curl -s http://localhost:8080/api/v1/links/{short_code} | jq .`
       - Returns JSON with short_code, original_url, created_at, total_clicks >= 1 (from redirect)
    8. **Delete:** `curl -s -X DELETE http://localhost:8080/api/v1/links/{short_code} -w "%{http_code}"`
       - Returns 200, subsequent GET returns 404
    9. **Search:** `curl -s "http://localhost:8080/api/v1/links?search=example" | jq .`
       - Returns filtered results
    10. **Duplicate URL:** POST same URL again — verify behavior (either returns existing or creates new, depending on implementation choice)
  </verify>
  <done>
    All 5 URL API endpoints work with real PostgreSQL data:
    - Shorten creates URLs with NanoID codes and UUIDv7 PKs
    - Redirect performs HTTP 302 and increments click count
    - List returns paginated results with search support
    - Detail returns link info with click count
    - Delete performs hard delete
  </done>
</task>

</tasks>

<verification>
Complete end-to-end flow test:
1. Start fresh: `docker compose down -v && docker compose up -d postgres` + apply migrations
2. Create URL: POST /api/v1/urls with real URL
3. Verify in DB: `docker compose exec postgres psql -U postgres -d shortener -c "SELECT * FROM urls"`
4. Redirect: GET /:code returns 302
5. Verify click count incremented: GET /api/v1/links/:code shows total_clicks >= 1
6. List with pagination: GET /api/v1/links?page=1&per_page=5 shows created URL
7. Search: GET /api/v1/links?search=example filters correctly
8. Delete: DELETE /api/v1/links/:code removes from DB
9. All errors return RFC 7807 Problem Details format
</verification>

<success_criteria>
- URL API connects to PostgreSQL on startup via DataSource config
- POST /api/v1/urls creates real URLs with NanoID 8-char codes and UUIDv7 primary keys
- GET /:code returns HTTP 302 redirect to original URL
- Click count incremented atomically on each redirect
- GET /api/v1/links returns paginated list with search support
- GET /api/v1/links/:code returns link details with click count
- DELETE /api/v1/links/:code performs hard delete
- All error responses use RFC 7807 Problem Details format
- No stub/mock data remains in any logic file
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-migration/08-02-SUMMARY.md`
</output>
