---
phase: 08-database-migration
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - services/analytics-rpc/internal/config/config.go
  - services/analytics-rpc/internal/svc/servicecontext.go
  - services/analytics-rpc/internal/logic/getclickcountlogic.go
  - services/analytics-rpc/etc/analytics.yaml
autonomous: true

must_haves:
  truths:
    - "Analytics RPC connects to PostgreSQL on startup"
    - "GetClickCount returns real click count from PostgreSQL clicks table"
    - "GetClickCount returns 0 for unknown short codes (not an error)"
  artifacts:
    - path: "services/analytics-rpc/internal/config/config.go"
      provides: "Config with DataSource for PostgreSQL"
      contains: "DataSource"
    - path: "services/analytics-rpc/internal/svc/servicecontext.go"
      provides: "ServiceContext with ClickModel dependency"
      contains: "ClickModel"
    - path: "services/analytics-rpc/internal/logic/getclickcountlogic.go"
      provides: "Real click count query replacing stub"
      contains: "CountByShortCode"
  key_links:
    - from: "services/analytics-rpc/internal/svc/servicecontext.go"
      to: "services/analytics-rpc/model/clicksmodel.go"
      via: "model.NewClicksModel(conn)"
      pattern: "NewClicksModel"
    - from: "services/analytics-rpc/internal/logic/getclickcountlogic.go"
      to: "services/analytics-rpc/model"
      via: "svcCtx.ClickModel.CountByShortCode"
      pattern: "ClickModel\\.CountByShortCode"
---

<objective>
Wire Analytics RPC service to PostgreSQL by replacing the stub GetClickCount with a real database query against the clicks table.

Purpose: Transform the Analytics RPC from returning hardcoded 42 to querying real click data from PostgreSQL.

Output: Analytics RPC GetClickCount returns actual click counts from the database.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-database-migration/08-RESEARCH.md
@.planning/phases/08-database-migration/08-CONTEXT.md
@.planning/phases/08-database-migration/08-01-SUMMARY.md
@services/analytics-rpc/analytics.proto
@services/analytics-rpc/internal/config/config.go
@services/analytics-rpc/internal/svc/servicecontext.go
@services/analytics-rpc/internal/logic/getclickcountlogic.go
@services/analytics-rpc/model/clicksmodel.go
@services/analytics-rpc/model/clicksmodel_gen.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire PostgreSQL connection and ClickModel to ServiceContext</name>
  <files>
    services/analytics-rpc/internal/config/config.go
    services/analytics-rpc/internal/svc/servicecontext.go
    services/analytics-rpc/etc/analytics.yaml
  </files>
  <action>
    **Step 1: Add DataSource to config.**
    Edit `services/analytics-rpc/internal/config/config.go`:
    ```go
    type Config struct {
      zrpc.RpcServerConf
      DataSource string
    }
    ```

    **Step 2: Add DataSource to YAML config.**
    Edit `services/analytics-rpc/etc/analytics.yaml` — add:
    ```yaml
    DataSource: postgres://postgres:postgres@localhost:5432/shortener?sslmode=disable
    ```

    **Step 3: Wire ClickModel in ServiceContext.**
    Edit `services/analytics-rpc/internal/svc/servicecontext.go`:
    ```go
    import (
      "go-shortener/services/analytics-rpc/internal/config"
      "go-shortener/services/analytics-rpc/model"

      "github.com/zeromicro/go-zero/core/stores/sqlx"
      _ "github.com/lib/pq"
    )

    type ServiceContext struct {
      Config     config.Config
      ClickModel model.ClicksModel
    }

    func NewServiceContext(c config.Config) *ServiceContext {
      conn := sqlx.NewSqlConn("postgres", c.DataSource)
      return &ServiceContext{
        Config:     c,
        ClickModel: model.NewClicksModel(conn),
      }
    }
    ```

    **Step 4: Verify compilation.**
    ```bash
    go build ./services/analytics-rpc/...
    ```
  </action>
  <verify>
    1. `go build ./services/analytics-rpc/...` compiles without errors
    2. `grep "DataSource" services/analytics-rpc/internal/config/config.go` shows the field
    3. `grep "ClickModel" services/analytics-rpc/internal/svc/servicecontext.go` shows the field
  </verify>
  <done>Analytics RPC ServiceContext creates PostgreSQL connection and ClickModel on startup</done>
</task>

<task type="auto">
  <name>Task 2: Replace GetClickCount stub with real database query</name>
  <files>
    services/analytics-rpc/internal/logic/getclickcountlogic.go
  </files>
  <action>
    **Replace the stub GetClickCount logic with a real database query.**

    Edit `services/analytics-rpc/internal/logic/getclickcountlogic.go`:

    ```go
    func (l *GetClickCountLogic) GetClickCount(in *analytics.GetClickCountRequest) (*analytics.GetClickCountResponse, error) {
      logx.WithContext(l.ctx).Infow("get click count",
        logx.Field("short_code", in.ShortCode),
      )

      count, err := l.svcCtx.ClickModel.CountByShortCode(l.ctx, in.ShortCode)
      if err != nil {
        logx.WithContext(l.ctx).Errorw("failed to get click count",
          logx.Field("short_code", in.ShortCode),
          logx.Field("error", err.Error()),
        )
        return nil, err
      }

      return &analytics.GetClickCountResponse{
        ShortCode:   in.ShortCode,
        TotalClicks: count,
      }, nil
    }
    ```

    **Key behaviors:**
    - Queries `CountByShortCode` which does `SELECT COUNT(*) FROM clicks WHERE short_code = $1`
    - For unknown short codes, COUNT returns 0 (not an error) — this matches v1.0 behavior (zero clicks returns 200 with total_clicks: 0)
    - On actual database errors, log and return the error (gRPC will translate to appropriate status code)
    - No need to check if short_code exists in urls table — analytics just counts clicks, URL validation is the URL API's concern

    **Verify compilation:**
    ```bash
    go build ./services/analytics-rpc/...
    ```
  </action>
  <verify>
    1. `go build ./services/analytics-rpc/...` compiles without errors
    2. `grep -c "stub" services/analytics-rpc/internal/logic/getclickcountlogic.go` returns 0 (no stub references)
    3. `grep "CountByShortCode" services/analytics-rpc/internal/logic/getclickcountlogic.go` shows real DB call
    4. Start PostgreSQL and Analytics RPC:
       ```bash
       docker compose up -d postgres
       go run services/analytics-rpc/analytics.go -f services/analytics-rpc/etc/analytics.yaml &
       ```
    5. Test with grpcurl (or similar):
       - GetClickCount for unknown code returns total_clicks: 0
       - Insert a test click row manually, then GetClickCount returns 1
    6. Service starts without connection errors in logs
  </verify>
  <done>
    GetClickCount queries real PostgreSQL clicks table.
    Returns 0 for unknown codes (not error).
    No stub/mock data remains in logic.
  </done>
</task>

</tasks>

<verification>
1. Analytics RPC connects to PostgreSQL on startup (no connection errors in logs)
2. GetClickCount for non-existent code returns total_clicks: 0 (not error)
3. After manually inserting click rows, GetClickCount returns correct count
4. Service starts and runs alongside URL API without port conflicts (8081 vs 8080)
5. No stub responses remain (grep for "stub" or "42" in logic files)
</verification>

<success_criteria>
- Analytics RPC connects to PostgreSQL via DataSource config
- GetClickCount returns real count from clicks table
- Zero clicks returns 0, not error (matching v1.0 behavior)
- Service compiles and starts successfully
- No hardcoded stub data (42) remains in any logic file
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-migration/08-03-SUMMARY.md`
</output>
