---
phase: 05-production-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .mockery.yaml
  - Makefile
  - go.mod
  - go.sum
  - internal/urlservice/usecase/mocks/URLRepository.go
  - internal/analytics/usecase/mocks/ClickRepository.go
  - internal/analytics/usecase/mocks/GeoIPResolver.go
  - internal/analytics/usecase/mocks/DeviceDetector.go
  - internal/analytics/usecase/mocks/RefererClassifier.go
  - internal/testutil/dapr_mock.go
  - internal/urlservice/usecase/url_service_test.go
autonomous: true

must_haves:
  truths:
    - "Mockery generates mocks for all interfaces from YAML config"
    - "URL Service usecase layer has unit tests covering create, get, list, delete, and validation"
    - "Tests use generated mocks at repository and Dapr boundaries"
    - "Tests follow scenario-based style with setup/act/assert"
  artifacts:
    - path: ".mockery.yaml"
      provides: "Mockery configuration for all project interfaces"
      contains: "packages:"
    - path: "internal/urlservice/usecase/mocks/URLRepository.go"
      provides: "Generated mock for URLRepository interface"
      contains: "MockURLRepository"
    - path: "internal/urlservice/usecase/url_service_test.go"
      provides: "Unit tests for URLService business logic"
      min_lines: 100
  key_links:
    - from: "internal/urlservice/usecase/url_service_test.go"
      to: "internal/urlservice/usecase/mocks/URLRepository.go"
      via: "import mocks package"
      pattern: "mocks\\.NewMockURLRepository"
    - from: ".mockery.yaml"
      to: "internal/urlservice/usecase"
      via: "mockery config references interface package"
      pattern: "go-shortener/internal/urlservice/usecase"
---

<objective>
Set up mockery for the entire project and write comprehensive unit tests for the URL Service usecase layer.

Purpose: Establish the testing foundation (mockery config, testify dependency, generated mocks) that all subsequent test plans depend on. URL Service usecase has the most business logic (validation, deduplication, retry, click count enrichment, event publishing) making it the highest-value test target.

Output: `.mockery.yaml` config, generated mocks for all interfaces, and URL Service usecase unit tests with >80% coverage of the usecase package.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-production-readiness/05-RESEARCH.md

@internal/urlservice/usecase/url_service.go
@internal/urlservice/usecase/url_repository.go
@internal/urlservice/domain/errors.go
@internal/urlservice/domain/url.go
@internal/analytics/usecase/click_repository.go
@internal/analytics/usecase/analytics_service.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mockery configuration and mock generation for all interfaces</name>
  <files>
    .mockery.yaml
    Makefile
    go.mod
    go.sum
    internal/urlservice/usecase/mocks/URLRepository.go
    internal/analytics/usecase/mocks/ClickRepository.go
    internal/analytics/usecase/mocks/GeoIPResolver.go
    internal/analytics/usecase/mocks/DeviceDetector.go
    internal/analytics/usecase/mocks/RefererClassifier.go
    internal/testutil/dapr_mock.go
  </files>
  <action>
    1. Install mockery: `go install github.com/vektra/mockery/v3@latest`
    2. Add testify to go.mod: `go get github.com/stretchr/testify`
    3. Create `.mockery.yaml` at project root with configuration:
       - `with-expecter: true` for fluent expectation API
       - `dir: "{{.InterfaceDir}}/mocks"` to co-locate mocks with interfaces
       - `outpkg: mocks`
       - Packages section listing ALL interfaces:
         - `go-shortener/internal/urlservice/usecase` -> `URLRepository`
         - `go-shortener/internal/analytics/usecase` -> `ClickRepository`, `GeoIPResolver`, `DeviceDetector`, `RefererClassifier`
    4. Run `mockery` to generate all mocks
    5. Verify generated mock files exist in the expected `mocks/` subdirectories
    6. Run `go build ./...` to confirm no compilation errors
    7. Add `make generate-mocks` target to Makefile: `mockery --config .mockery.yaml`

    Note: The Dapr client interface (`dapr.Client`) is from an external package. For unit tests, create a minimal mock at `internal/testutil/dapr_mock.go` that implements `dapr.Client` with configurable behavior for `InvokeMethod` and `PublishEvent` methods. Use testify/mock as the base. Only implement the methods actually used by the codebase (InvokeMethod, PublishEvent, Close), and have all other methods panic with "not implemented". This keeps the mock focused and maintainable.
  </action>
  <verify>
    - `ls internal/urlservice/usecase/mocks/` shows `MockURLRepository.go`
    - `ls internal/analytics/usecase/mocks/` shows `MockClickRepository.go`, `MockGeoIPResolver.go`, `MockDeviceDetector.go`, `MockRefererClassifier.go`
    - `go build ./...` passes
    - `make generate-mocks` runs without error
  </verify>
  <done>All project interfaces have generated mocks via mockery, Dapr client mock helper exists, testify added to dependencies</done>
</task>

<task type="auto">
  <name>Task 2: URL Service usecase unit tests</name>
  <files>
    internal/urlservice/usecase/url_service_test.go
  </files>
  <action>
    Write comprehensive unit tests for `URLService` in `url_service_test.go`. Use scenario-based test style (each test function = one meaningful scenario, clear setup/act/assert sections).

    Test scenarios to cover:

    **CreateShortURL:**
    - `TestCreateShortURL_ValidURL_ReturnsNewShortURL` -- new URL saved successfully
    - `TestCreateShortURL_DuplicateURL_ReturnsExisting` -- deduplication returns existing record
    - `TestCreateShortURL_InvalidScheme_ReturnsError` -- ftp:// rejected
    - `TestCreateShortURL_EmptyHost_ReturnsError` -- https:// with no host rejected
    - `TestCreateShortURL_ExceedsMaxLength_ReturnsError` -- URL > 2048 chars rejected
    - `TestCreateShortURL_RepositoryError_ReturnsError` -- repo.Save returns error

    **GetByShortCode:**
    - `TestGetByShortCode_Exists_ReturnsURL` -- found in repo
    - `TestGetByShortCode_NotFound_ReturnsError` -- repo returns ErrURLNotFound

    **ListLinks:**
    - `TestListLinks_ReturnsPagedResults` -- correct pagination math (totalPages, offset)
    - `TestListLinks_InvalidSortField_ReturnsError` -- unsupported sort rejected
    - `TestListLinks_DefaultParams_UsesDescOrder` -- empty order defaults to desc
    - `TestListLinks_WithClickCounts_EnrichesFromDapr` -- Dapr invocation returns counts
    - `TestListLinks_DaprUnavailable_FallsToZeroClicks` -- nil Dapr client, clicks = 0

    **GetLinkDetail:**
    - `TestGetLinkDetail_ExistingLink_ReturnsWithClicks` -- enriched with click count
    - `TestGetLinkDetail_NotFound_ReturnsError` -- repo returns ErrURLNotFound

    **DeleteLink:**
    - `TestDeleteLink_Success_DeletesAndPublishesEvent` -- repo.Delete called, event published
    - `TestDeleteLink_NoDapr_DeletesWithoutEvent` -- nil client, no publish

    **validateURL (internal, tested through CreateShortURL):**
    - Valid http/https URLs pass
    - ftp, mailto schemes rejected
    - Empty host rejected
    - Over-length rejected

    Mock setup pattern for each test:
    ```go
    mockRepo := mocks.NewMockURLRepository(t)
    mockRepo.EXPECT().FindByOriginalURL(mock.Anything, "https://example.com").Return(nil, domain.ErrURLNotFound)
    mockRepo.EXPECT().Save(mock.Anything, mock.AnythingOfType("string"), "https://example.com").Return(&domain.URL{...}, nil)
    ```

    For Dapr client mocking, use the helper from `internal/testutil/dapr_mock.go`. Set up `InvokeMethod` to return JSON `{"total_clicks": 42}` for click count tests. Use `zap.NewNop()` for logger in all tests.

    Do NOT use t.Parallel() to avoid complexity. Use `require` for setup assertions, `assert` for test assertions.
  </action>
  <verify>
    - `go test ./internal/urlservice/usecase/ -v` -- all tests pass
    - `go test ./internal/urlservice/usecase/ -cover` -- coverage >80%
  </verify>
  <done>URL Service usecase layer has 15+ scenario-based unit tests covering all public methods, validation logic, deduplication, error handling, and Dapr integration paths. Coverage exceeds 80%.</done>
</task>

</tasks>

<verification>
- `go test ./internal/urlservice/usecase/ -v -count=1` -- all tests pass
- `go test ./internal/urlservice/usecase/ -coverprofile=coverage.out && go tool cover -func=coverage.out` -- verify >80% on url_service.go
- `go build ./...` -- no compilation errors across project
- `mockery --config .mockery.yaml --dry-run` -- mock config valid
</verification>

<success_criteria>
- mockery configured and generates mocks for all 5 interfaces
- URL Service usecase has >80% test coverage
- All tests pass with `go test ./internal/urlservice/usecase/ -v`
- Dapr client mock helper enables testing pub/sub and service invocation paths
</success_criteria>

<output>
After completion, create `.planning/phases/05-production-readiness/05-01-SUMMARY.md`
</output>
