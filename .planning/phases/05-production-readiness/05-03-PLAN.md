---
phase: 05-production-readiness
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/urlservice/delivery/http/handler.go
  - internal/urlservice/delivery/http/router.go
  - internal/analytics/delivery/http/handler.go
  - internal/analytics/delivery/http/router.go
  - cmd/url-service/main.go
  - cmd/analytics-service/main.go
  - internal/urlservice/repository/sqlite/url_repository_test.go
  - internal/analytics/repository/sqlite/click_repository_test.go
autonomous: true

must_haves:
  truths:
    - "Both services expose /healthz (liveness) and /readyz (readiness) endpoints"
    - "Readiness checks verify database connectivity and Dapr sidecar availability"
    - "Health checks bypass rate limiting on URL Service"
    - "Repository tests run against real in-memory SQLite with migrations"
    - "Repository tests verify all CRUD operations and edge cases"
  artifacts:
    - path: "internal/urlservice/delivery/http/handler.go"
      provides: "Health check handlers for URL Service"
      contains: "Healthz"
    - path: "internal/analytics/delivery/http/handler.go"
      provides: "Health check handlers for Analytics Service"
      contains: "Readyz"
    - path: "internal/urlservice/repository/sqlite/url_repository_test.go"
      provides: "Repository integration tests with in-memory SQLite"
      min_lines: 60
    - path: "internal/analytics/repository/sqlite/click_repository_test.go"
      provides: "Repository integration tests with in-memory SQLite"
      min_lines: 60
  key_links:
    - from: "internal/urlservice/delivery/http/router.go"
      to: "internal/urlservice/delivery/http/handler.go"
      via: "routes /healthz and /readyz"
      pattern: "r\\.Get\\(\"/health"
    - from: "internal/urlservice/repository/sqlite/url_repository_test.go"
      to: "internal/urlservice/database"
      via: "imports database.RunMigrations for test setup"
      pattern: "database\\.RunMigrations"
---

<objective>
Add health check endpoints to both services and write repository integration tests using in-memory SQLite.

Purpose: Health checks are required for Docker Compose readiness (Plan 04) and production deployment. Repository tests validate sqlc-generated queries against real SQLite, catching SQL bugs that unit tests with mocks cannot find. Dapr service invocation is already implemented in Phase 04 (verified -- no changes needed).

Output: `/healthz` and `/readyz` endpoints on both services, and repository test files for both services.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-production-readiness/05-RESEARCH.md

@internal/urlservice/delivery/http/handler.go
@internal/urlservice/delivery/http/router.go
@internal/urlservice/usecase/url_service.go
@internal/analytics/delivery/http/handler.go
@internal/analytics/delivery/http/router.go
@internal/urlservice/repository/sqlite/url_repository.go
@internal/analytics/repository/sqlite/click_repository.go
@internal/urlservice/database/database.go
@internal/analytics/database/database.go
@cmd/url-service/main.go
@cmd/analytics-service/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Health check endpoints for both services</name>
  <files>
    internal/urlservice/delivery/http/handler.go
    internal/urlservice/delivery/http/router.go
    internal/analytics/delivery/http/handler.go
    internal/analytics/delivery/http/router.go
    cmd/url-service/main.go
    cmd/analytics-service/main.go
  </files>
  <action>
    Add `/healthz` (liveness) and `/readyz` (readiness) endpoints to both services per locked decision.

    **URL Service handler.go:**
    - Add `db *sql.DB` field to Handler struct (needed for readiness check)
    - Update `NewHandler` to accept `*sql.DB` parameter
    - Add `Healthz` method: always returns 200 with `{"status": "ok"}` (liveness = process alive)
    - Add `Readyz` method: checks DB connectivity via `db.PingContext(ctx)` with 2-second timeout. If Dapr client is non-nil, check Dapr sidecar health via HTTP GET to `http://localhost:3500/v1.0/healthz` (not InvokeMethod -- just a simple HTTP check). Return 200 `{"status": "ready"}` if all pass, 503 `{"status": "unavailable", "reason": "..."}` on failure.

    **URL Service router.go:**
    - Add routes BEFORE rate limiter middleware. Restructure: add health check routes outside the rate limiter scope. Use a chi.Group or route ordering to achieve this:
      ```go
      // Health checks (no rate limiting)
      r.Get("/healthz", handler.Healthz)
      r.Get("/readyz", handler.Readyz)

      // Business routes (rate limited)
      r.Group(func(r chi.Router) {
        r.Use(rateLimiter.Middleware)
        r.Get("/{code}", handler.Redirect)
        r.Route("/api/v1", func(r chi.Router) { ... })
      })
      ```

    **Analytics Service handler.go:**
    - Add `db *sql.DB` field to Handler struct
    - Update `NewHandler` to accept `*sql.DB` parameter
    - Add `Healthz` method: always 200 `{"status": "ok"}`
    - Add `Readyz` method: checks DB via PingContext with 2-second timeout. Analytics Service has no Dapr client in handler (it receives events, doesn't invoke). Return 200/503 appropriately.

    **Analytics Service router.go:**
    - Add `/healthz` and `/readyz` routes

    **Update main.go for both services:**
    - Pass `db` to `NewHandler` in addition to existing params
    - URL Service: `handler := httpdelivery.NewHandler(service, baseURL, daprClient, logger, db)`
    - Analytics Service: `handler := analyticshttp.NewHandler(service, logger, db)`

    Health check response format: `{"status": "ok"|"ready"|"unavailable", "reason": "..." (only on failure)}`
    Content-Type: `application/json`

    **Note on Dapr service invocation (INFR-02):** The URL Service already uses `daprClient.InvokeMethod` for click count enrichment (added in Phase 04). The deletion cascade already uses pub/sub. Both match the locked decisions. No code changes needed for service invocation -- just document in SUMMARY.
  </action>
  <verify>
    - `go build ./cmd/url-service && go build ./cmd/analytics-service` -- both compile
    - `grep -n "Healthz\|Readyz" internal/urlservice/delivery/http/handler.go` -- both methods exist
    - `grep -n "Healthz\|Readyz" internal/analytics/delivery/http/handler.go` -- both methods exist
    - `grep -n "healthz\|readyz" internal/urlservice/delivery/http/router.go` -- routes registered
    - `grep -n "healthz\|readyz" internal/analytics/delivery/http/router.go` -- routes registered
  </verify>
  <done>Both services expose /healthz and /readyz endpoints. Liveness always returns 200. Readiness checks DB and Dapr connectivity, returning 503 when dependencies are down. Health checks bypass rate limiting.</done>
</task>

<task type="auto">
  <name>Task 2: Repository integration tests with in-memory SQLite</name>
  <files>
    internal/urlservice/repository/sqlite/url_repository_test.go
    internal/analytics/repository/sqlite/click_repository_test.go
  </files>
  <action>
    Write integration tests for both repositories using in-memory SQLite. These test real SQL queries generated by sqlc against actual database schema (migrations applied).

    **Test helper (shared pattern in each test file):**
    ```go
    func setupTestDB(t *testing.T) *sql.DB {
      db, err := sql.Open("sqlite", ":memory:")
      require.NoError(t, err)
      t.Cleanup(func() { db.Close() })

      // Run migrations (reuse the database package)
      err = database.RunMigrations(db)
      require.NoError(t, err)

      return db
    }
    ```
    Import `database` package from the respective service's database package. Import `_ "modernc.org/sqlite"` for driver registration.

    **URL Repository tests (`url_repository_test.go`):**
    - `TestURLRepository_Save_CreatesRecord` -- save URL, verify fields
    - `TestURLRepository_FindByShortCode_Exists` -- save then find
    - `TestURLRepository_FindByShortCode_NotFound` -- returns domain.ErrURLNotFound
    - `TestURLRepository_FindByOriginalURL_Exists` -- deduplication lookup
    - `TestURLRepository_FindByOriginalURL_NotFound` -- returns domain.ErrURLNotFound
    - `TestURLRepository_Save_DuplicateShortCode_ReturnsError` -- UNIQUE constraint
    - `TestURLRepository_FindAll_Pagination` -- save 5 URLs, query page 1 limit 2, verify 2 returned
    - `TestURLRepository_FindAll_SortOrder` -- verify desc vs asc ordering
    - `TestURLRepository_FindAll_SearchFilter` -- search by URL substring
    - `TestURLRepository_Count_WithFilters` -- count with date and search filters
    - `TestURLRepository_Delete_RemovesRecord` -- delete then find returns not found
    - `TestURLRepository_Delete_Idempotent` -- delete non-existent code succeeds

    **Click Repository tests (`click_repository_test.go`):**
    - `TestClickRepository_InsertClick_StoresRecord` -- insert and verify via count
    - `TestClickRepository_CountByShortCode_ReturnsCount` -- insert 3 clicks, count = 3
    - `TestClickRepository_CountByShortCode_NoClicks_ReturnsZero`
    - `TestClickRepository_CountInRange_FiltersCorrectly` -- insert clicks at different times, verify range filter
    - `TestClickRepository_CountByCountryInRange_GroupsCorrectly` -- 2 US + 1 UK clicks, verify grouping
    - `TestClickRepository_CountByDeviceInRange_GroupsCorrectly`
    - `TestClickRepository_CountBySourceInRange_GroupsCorrectly`
    - `TestClickRepository_GetClickDetails_ReturnsPaginated` -- insert 5 clicks, limit 3, verify hasMore=true
    - `TestClickRepository_GetClickDetails_Cursor` -- verify cursor-based pagination returns correct subset
    - `TestClickRepository_DeleteByShortCode_RemovesAll` -- insert clicks, delete, count = 0
    - `TestClickRepository_DeleteByShortCode_OnlyAffectsTargetCode` -- delete code1 clicks, code2 clicks remain

    Each test creates its own data (no shared state). Use `require` for setup, `assert` for assertions.
    Use `github.com/stretchr/testify` (added in Plan 01).
  </action>
  <verify>
    - `go test ./internal/urlservice/repository/sqlite/ -v` -- all tests pass
    - `go test ./internal/analytics/repository/sqlite/ -v` -- all tests pass
    - `go test ./internal/urlservice/repository/sqlite/ -cover` -- >80% on url_repository.go
    - `go test ./internal/analytics/repository/sqlite/ -cover` -- >80% on click_repository.go
  </verify>
  <done>Both repository packages have integration tests running against in-memory SQLite with real migrations. All CRUD operations, pagination, filtering, and edge cases tested with >80% coverage.</done>
</task>

</tasks>

<verification>
- `go build ./...` -- all packages compile after health check changes
- `go test ./internal/urlservice/repository/sqlite/ -v -count=1` -- all pass
- `go test ./internal/analytics/repository/sqlite/ -v -count=1` -- all pass
- `go test ./... -count=1` -- full test suite passes
</verification>

<success_criteria>
- Both services have /healthz (200 always) and /readyz (200 when healthy, 503 when not)
- Health checks bypass rate limiting on URL Service
- URL repository has 12+ integration tests with >80% coverage
- Click repository has 11+ integration tests with >80% coverage
- All tests use in-memory SQLite (no file system state)
- Dapr service invocation verified for click count enrichment (no changes needed)
</success_criteria>

<output>
After completion, create `.planning/phases/05-production-readiness/05-03-SUMMARY.md`
</output>
