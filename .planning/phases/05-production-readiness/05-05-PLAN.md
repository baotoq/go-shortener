---
phase: 05-production-readiness
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-04"]
files_modified:
  - .github/workflows/ci.yml
  - .coverage.yaml
  - Makefile
autonomous: true

must_haves:
  truths:
    - "CI pipeline runs on PRs and pushes to main/master"
    - "Pipeline lints with golangci-lint"
    - "Pipeline runs unit tests with coverage reporting"
    - "Pipeline builds both binaries"
    - "Pipeline builds both Docker images"
    - "Coverage threshold enforced at >80%"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline"
      contains: "golangci-lint"
    - path: ".coverage.yaml"
      provides: "Coverage threshold configuration"
      contains: "threshold"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: ".golangci.yml"
      via: "golangci-lint uses config file"
      pattern: "golangci-lint"
    - from: ".github/workflows/ci.yml"
      to: ".coverage.yaml"
      via: "go-test-coverage reads threshold config"
      pattern: "go-test-coverage"
    - from: ".github/workflows/ci.yml"
      to: "Dockerfile.url-service"
      via: "docker build step references Dockerfile"
      pattern: "Dockerfile"
---

<objective>
Create GitHub Actions CI/CD pipeline with lint, test, build, and Docker image stages.

Purpose: Automated quality gates on every PR ensure code quality, test coverage, and build integrity. This is the final piece of production readiness -- automated verification that the codebase stays healthy.

Output: GitHub Actions workflow file, coverage threshold config, and updated Makefile with CI-related targets.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-production-readiness/05-RESEARCH.md
@.planning/phases/05-production-readiness/05-04-SUMMARY.md

@.golangci.yml
@Makefile
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: GitHub Actions CI workflow</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
    Create GitHub Actions workflow per locked decisions.

    **Trigger:** PRs and pushes to main/master only (not every branch push per locked decision).
    ```yaml
    on:
      push:
        branches: [main, master]
      pull_request:
        branches: [main, master]
    ```

    **Jobs:**

    **Job 1: lint**
    - runs-on: ubuntu-latest
    - steps:
      1. actions/checkout@v4
      2. actions/setup-go@v5 with go-version: '1.24' and cache: true
      3. Install golangci-lint: `go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest` (v2.9.0+)
      4. Run: `golangci-lint run --timeout 5m`

    **Job 2: test**
    - runs-on: ubuntu-latest
    - steps:
      1. actions/checkout@v4
      2. actions/setup-go@v5 with go-version: '1.24' and cache: true
      3. Run unit tests: `go test -v -race -coverprofile=coverage.out -covermode=atomic ./...`
      4. Install go-test-coverage: `go install github.com/vladopajic/go-test-coverage/v2@latest`
      5. Enforce coverage: `go-test-coverage --config=.coverage.yaml`
      6. Upload coverage artifact (optional, for visibility)

    Note on integration tests: The locked decision says "Integration tests use testcontainers to spin up Dapr sidecars in CI". However, testcontainers integration tests are not yet written (they would be a future enhancement -- the current repo tests use in-memory SQLite which runs fine without containers). For now, the CI runs all tests including the in-memory SQLite repository tests. A comment in the workflow notes where testcontainers integration tests would be added.

    **Job 3: build**
    - runs-on: ubuntu-latest
    - needs: [lint, test]  -- only build if lint+test pass
    - steps:
      1. actions/checkout@v4
      2. actions/setup-go@v5 with go-version: '1.24' and cache: true
      3. Build binaries: `CGO_ENABLED=0 go build -ldflags="-w -s" -o bin/url-service ./cmd/url-service && CGO_ENABLED=0 go build -ldflags="-w -s" -o bin/analytics-service ./cmd/analytics-service`
      4. docker/setup-buildx-action@v3
      5. Build URL Service image: docker/build-push-action@v5 with file: Dockerfile.url-service, push: false, tags: url-service:${{ github.sha }}, cache-from: type=gha, cache-to: type=gha,mode=max
      6. Build Analytics Service image: docker/build-push-action@v5 with file: Dockerfile.analytics-service, push: false, tags: analytics-service:${{ github.sha }}, cache-from: type=gha, cache-to: type=gha,mode=max

    Docker images are built but NOT pushed (no registry configured yet -- that's a deployment concern beyond this phase).
  </action>
  <verify>
    - `.github/workflows/ci.yml` exists with valid YAML
    - `yamllint .github/workflows/ci.yml` or manual review -- valid syntax
    - Trigger conditions include main and master branches
    - All 3 jobs defined: lint, test, build
    - build depends on lint and test
  </verify>
  <done>GitHub Actions CI pipeline with lint (golangci-lint), test (with coverage enforcement), and build (binaries + Docker images) stages. Triggers on PRs and pushes to main/master.</done>
</task>

<task type="auto">
  <name>Task 2: Coverage configuration and Makefile CI targets</name>
  <files>
    .coverage.yaml
    Makefile
  </files>
  <action>
    **.coverage.yaml:**
    Create go-test-coverage threshold configuration:
    ```yaml
    threshold:
      total: 80
      package: 70

    override:
      - path: "go-shortener/internal/urlservice/repository/sqlite/sqlc"
        threshold: 0  # Generated code, skip coverage
      - path: "go-shortener/internal/analytics/repository/sqlite/sqlc"
        threshold: 0  # Generated code, skip coverage
      - path: "go-shortener/cmd"
        threshold: 50  # Main packages are harder to unit test
    ```

    Set total threshold at 80% per locked decision. Package threshold at 70% (slightly lower to allow for some edge cases). Override generated sqlc code to 0% (not meaningful to test generated code). Override cmd packages to 50% (main.go wiring is hard to unit test).

    **Makefile updates:**
    Add CI-related targets:
    ```makefile
    # Testing
    test:
    	go test -v -race ./...

    test-coverage:
    	go test -race -coverprofile=coverage.out -covermode=atomic ./...
    	go tool cover -func=coverage.out

    # Linting
    lint:
    	golangci-lint run --timeout 5m

    # Docker
    docker-up:
    	docker compose up --build -d

    docker-down:
    	docker compose down

    # CI (runs all checks locally)
    ci: lint test-coverage build
    ```

    Update .PHONY to include all new targets.
  </action>
  <verify>
    - `make test` -- runs all tests
    - `make lint` -- runs linter (requires golangci-lint installed)
    - `make test-coverage` -- generates coverage report
    - `cat .coverage.yaml` -- threshold: total: 80
  </verify>
  <done>Coverage thresholds configured at 80% total with overrides for generated code. Makefile has test, lint, test-coverage, docker-up, docker-down, and ci targets.</done>
</task>

</tasks>

<verification>
- `.github/workflows/ci.yml` has valid YAML structure
- Workflow triggers on push to main/master and PRs to main/master
- Pipeline has lint -> test -> build flow with correct dependencies
- `.coverage.yaml` enforces 80% total threshold
- `make ci` runs lint, test-coverage, and build locally
- All existing tests still pass: `go test ./... -count=1`
</verification>

<success_criteria>
- GitHub Actions workflow exists with 3 jobs: lint, test, build
- CI triggers only on main/master (not every branch) per locked decision
- Coverage threshold enforced at 80% via go-test-coverage
- Docker images built in CI (not pushed)
- Makefile provides local CI workflow via `make ci`
- Generated sqlc code excluded from coverage threshold
</success_criteria>

<output>
After completion, create `.planning/phases/05-production-readiness/05-05-SUMMARY.md`
</output>
