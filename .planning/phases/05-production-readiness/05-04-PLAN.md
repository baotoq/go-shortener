---
phase: 05-production-readiness
plan: 04
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - Dockerfile.url-service
  - Dockerfile.analytics-service
  - docker-compose.yml
  - .dockerignore
  - .golangci.yml
autonomous: true

must_haves:
  truths:
    - "Docker Compose starts both services with Dapr sidecars locally"
    - "Multi-stage Dockerfiles produce minimal images with distroless base"
    - "GeoIP database is mounted as a volume, not baked into images"
    - "Dapr sidecars are separate containers paired with each service"
    - "Health checks gate service startup ordering via depends_on condition"
    - "golangci-lint configuration is ready for CI pipeline"
  artifacts:
    - path: "Dockerfile.url-service"
      provides: "Multi-stage Dockerfile for URL Service"
      contains: "CGO_ENABLED=0"
    - path: "Dockerfile.analytics-service"
      provides: "Multi-stage Dockerfile for Analytics Service"
      contains: "distroless"
    - path: "docker-compose.yml"
      provides: "Docker Compose orchestration with Dapr sidecars"
      contains: "daprio/daprd"
    - path: ".golangci.yml"
      provides: "golangci-lint configuration for CI"
      contains: "linters:"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile.url-service"
      via: "build context references Dockerfile"
      pattern: "dockerfile.*Dockerfile\\.url-service"
    - from: "docker-compose.yml"
      to: "dapr/components"
      via: "volume mount for Dapr components"
      pattern: "dapr/components"
---

<objective>
Create Dockerfiles for both services, Docker Compose for local orchestration with Dapr sidecars, and golangci-lint configuration.

Purpose: Docker Compose enables running the full system locally (both services + Dapr sidecars) in a single command, replacing the manual `dapr run` workflow. Multi-stage Dockerfiles produce minimal production images. golangci-lint config is needed by the CI pipeline (Plan 05).

Output: Two Dockerfiles, docker-compose.yml, .dockerignore, and .golangci.yml.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-production-readiness/05-RESEARCH.md
@.planning/phases/05-production-readiness/05-03-SUMMARY.md

@Makefile
@go.mod
@cmd/url-service/main.go
@cmd/analytics-service/main.go
@dapr/components/pubsub.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-stage Dockerfiles and .dockerignore</name>
  <files>
    Dockerfile.url-service
    Dockerfile.analytics-service
    .dockerignore
  </files>
  <action>
    Create multi-stage Dockerfiles per locked decision: build in Go image, copy binary to distroless.

    **Dockerfile.url-service:**
    ```dockerfile
    # Build stage
    FROM golang:1.24 AS builder
    WORKDIR /build
    COPY go.mod go.sum ./
    RUN go mod download
    COPY . .
    RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /app/url-service ./cmd/url-service

    # Runtime stage
    FROM gcr.io/distroless/static-debian12:latest
    COPY --from=builder /app/url-service /url-service
    # Copy embedded migration files (they're embedded in binary via //go:embed, so not needed separately)
    EXPOSE 8080
    ENTRYPOINT ["/url-service"]
    ```

    **Dockerfile.analytics-service:**
    Same pattern but builds `./cmd/analytics-service` and exposes port 8081.

    **Critical: CGO_ENABLED=0** -- This project uses `modernc.org/sqlite` (pure Go, no CGO), so CGO_ENABLED=0 is safe. The binary will work in distroless without libc.

    **Critical: Embedded migrations** -- Both services use `//go:embed migrations/*.sql` in their database packages. The migration SQL files are embedded into the binary at build time, so they do NOT need to be copied to the runtime image separately. The `COPY . .` in the build stage includes them for compilation.

    **.dockerignore:**
    ```
    .git
    .planning
    data/
    bin/
    *.db
    *.db-wal
    *.db-shm
    .env
    ```
    Exclude planning docs, data files, binaries, and database files from Docker context.
  </action>
  <verify>
    - `docker build -f Dockerfile.url-service -t url-service:test .` -- builds successfully
    - `docker build -f Dockerfile.analytics-service -t analytics-service:test .` -- builds successfully
    - `docker images url-service:test --format '{{.Size}}'` -- image is small (under 30MB)
  </verify>
  <done>Both services have multi-stage Dockerfiles producing minimal distroless images with CGO_ENABLED=0. Build stage caches go mod download. .dockerignore excludes non-essential files.</done>
</task>

<task type="auto">
  <name>Task 2: Docker Compose with Dapr sidecars and golangci-lint config</name>
  <files>
    docker-compose.yml
    .golangci.yml
  </files>
  <action>
    **docker-compose.yml:**
    Create Docker Compose v2 file with both services and their Dapr sidecars per locked decisions:

    Services:
    1. `url-service` -- builds from Dockerfile.url-service, port 8080, depends on url-service-dapr healthy
    2. `url-service-dapr` -- daprio/daprd:1.13.0, network_mode: "service:url-service", app-id=url-service, app-port=8080, dapr-http-port=3500
    3. `analytics-service` -- builds from Dockerfile.analytics-service, port 8081, depends on analytics-service-dapr healthy
    4. `analytics-service-dapr` -- daprio/daprd:1.13.0, network_mode: "service:analytics-service", app-id=analytics-service, app-port=8081, dapr-http-port=3500

    Key configuration:
    - `network_mode: "service:{app}"` for Dapr sidecar pairing (sidecar shares network namespace with app)
    - Health checks on all 4 containers:
      - App containers: `wget --spider -q http://localhost:{port}/healthz` (distroless has no curl; use wget or a custom binary -- actually distroless has NEITHER curl nor wget. Use the health check endpoint from the Go binary itself. Option: since the app listens on the port, use `["CMD", "/url-service", "--health"]` or simply rely on the Dapr sidecar health to gate. Better approach: don't add healthcheck to app containers since they're Go binaries in distroless with no shell tools. Instead, rely on Dapr sidecar health checks and depends_on ordering.)
      - Dapr sidecars: `wget --spider -q http://localhost:3500/v1.0/healthz` (daprd image is based on Alpine/Debian, has wget)
    - `start_period: 30s` on Dapr sidecars (initialization time per research)
    - GeoIP database mounted as read-only volume: `./data/GeoLite2-Country.mmdb:/data/GeoLite2-Country.mmdb:ro` per locked decision
    - Named volumes for SQLite databases (url-data, analytics-data)
    - Environment variables for both services matching existing defaults

    **Dapr components:** Mount `./dapr/components:/components:ro` into Dapr sidecar containers.

    **Health check strategy for distroless containers:**
    Since distroless has no shell, curl, or wget, use one of:
    a) Skip healthcheck on app containers -- rely on Dapr sidecar health + depends_on
    b) Add a tiny health check binary (too complex)

    Go with option (a): App containers have no healthcheck directive. Dapr sidecars have healthchecks. depends_on uses `condition: service_healthy` on Dapr sidecars only. The app starting on its port is sufficient indication of liveness.

    Add `make docker-up` and `make docker-down` targets to Makefile for convenience.

    **.golangci.yml:**
    Create golangci-lint configuration per research recommendations:
    - Linters: errcheck, gosimple, govet, ineffassign, staticcheck, unused, misspell, revive, gocyclo, goconst, unparam
    - Exclude sqlc generated directories from linting: `internal/*/repository/sqlite/sqlc`
    - Exclude errcheck in test files (tests intentionally ignore errors)
    - gocyclo min-complexity: 15
    - goconst min-len: 3, min-occurrences: 3
    - timeout: 5m
    - tests: true (lint test files too, except for excluded rules)
  </action>
  <verify>
    - `docker compose config` -- validates docker-compose.yml syntax
    - `docker compose up --build -d` -- starts all containers (may need Dapr images pulled first)
    - `docker compose ps` -- shows all 4 containers running
    - `curl http://localhost:8080/healthz` -- URL Service responds 200
    - `curl http://localhost:8081/healthz` -- Analytics Service responds 200
    - `docker compose down` -- clean shutdown
    - `golangci-lint run --timeout 5m` -- linting passes (install golangci-lint first if needed)
  </verify>
  <done>Docker Compose starts both services with Dapr sidecars in a single command. Dapr sidecars use health checks for startup ordering. GeoIP database mounted as volume. golangci-lint configured with sensible defaults excluding generated code.</done>
</task>

</tasks>

<verification>
- `docker compose config` -- valid YAML
- `docker compose up --build -d && sleep 30 && curl http://localhost:8080/healthz && docker compose down` -- full lifecycle works
- `golangci-lint run` -- passes
- `docker images | grep -E "url-service|analytics-service"` -- both images exist
</verification>

<success_criteria>
- Both Dockerfiles build successfully with CGO_ENABLED=0 and distroless base
- Docker Compose starts 4 containers (2 apps + 2 Dapr sidecars)
- Dapr sidecars have health checks with 30s start_period
- GeoIP database is a mounted volume (not baked in)
- golangci-lint passes on the codebase
- Makefile has docker-up/docker-down targets
</success_criteria>

<output>
After completion, create `.planning/phases/05-production-readiness/05-04-SUMMARY.md`
</output>
