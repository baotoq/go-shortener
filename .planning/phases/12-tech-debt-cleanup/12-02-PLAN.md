---
phase: 12-tech-debt-cleanup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/analytics-consumer/internal/svc/servicecontext.go
  - services/analytics-consumer/internal/mqs/clickeventconsumer_test.go
autonomous: true
requirements:
  - DEBT-02

must_haves:
  truths:
    - "analytics-consumer mqs package test coverage is above 80%"
    - "GeoIP country resolution is testable via mock without a real .mmdb file"
    - "Mobile device type detection is covered by tests"
  artifacts:
    - path: "services/analytics-consumer/internal/svc/servicecontext.go"
      provides: "GeoIPReader interface for testability"
      contains: "GeoIPReader interface"
    - path: "services/analytics-consumer/internal/mqs/clickeventconsumer_test.go"
      provides: "Tests for resolveCountry with GeoDB and Mobile UA"
      contains: "mockGeoIPReader"
  key_links:
    - from: "services/analytics-consumer/internal/mqs/clickeventconsumer.go"
      to: "services/analytics-consumer/internal/svc/servicecontext.go"
      via: "svcCtx.GeoDB.Country(parsedIP)"
      pattern: "svcCtx\\.GeoDB"
    - from: "services/analytics-consumer/internal/mqs/clickeventconsumer_test.go"
      to: "services/analytics-consumer/internal/svc/servicecontext.go"
      via: "mockGeoIPReader satisfies GeoIPReader interface"
      pattern: "mockGeoIPReader"
---

<objective>
Improve analytics-consumer test coverage above 80% by introducing a GeoIPReader interface and adding tests for resolveCountry (GeoDB paths) and resolveDeviceType (Mobile UA).

Purpose: Increase confidence in the click enrichment pipeline by testing previously uncovered GeoIP country resolution and mobile device detection paths.
Output: GeoIPReader interface in servicecontext.go, 5 new tests in clickeventconsumer_test.go, coverage > 80% in mqs package.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-tech-debt-cleanup/12-RESEARCH.md
@services/analytics-consumer/internal/svc/servicecontext.go
@services/analytics-consumer/internal/mqs/clickeventconsumer.go
@services/analytics-consumer/internal/mqs/clickeventconsumer_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Introduce GeoIPReader interface in ServiceContext</name>
  <files>services/analytics-consumer/internal/svc/servicecontext.go</files>
  <action>
    Refactor ServiceContext to use a GeoIPReader interface instead of a concrete `*geoip2.Reader` type. This enables mock-based testing of resolveCountry without needing a real .mmdb file.

    1. Add `"net"` to the import block (needed for `net.IP` in the interface signature).

    2. Define the GeoIPReader interface above the ServiceContext struct:
       ```go
       // GeoIPReader abstracts country lookup for testability.
       // *geoip2.Reader naturally satisfies this interface.
       type GeoIPReader interface {
           Country(ipAddress net.IP) (*geoip2.Country, error)
       }
       ```

    3. Change the `GeoDB` field type from `*geoip2.Reader` to `GeoIPReader`:
       ```go
       type ServiceContext struct {
           Config     config.Config
           ClickModel model.ClicksModel
           GeoDB      GeoIPReader
       }
       ```

    4. In `NewServiceContext`, change the local variable type to use the interface to avoid typed-nil pitfall:
       ```go
       var geoDB GeoIPReader
       if c.GeoIPPath != "" {
           gdb, geoErr := geoip2.Open(c.GeoIPPath)
           if geoErr != nil {
               logx.Infof("GeoIP database not available at %s, falling back to Unknown", c.GeoIPPath)
           } else {
               geoDB = gdb
           }
       }
       ```
       This is CRITICAL: do NOT use `var geoDB *geoip2.Reader` because assigning a nil `*geoip2.Reader` to a `GeoIPReader` interface creates a typed nil (non-nil interface value), which would break the `svcCtx.GeoDB == nil` check in resolveCountry.

    No changes needed to `clickeventconsumer.go` — it already calls `svcCtx.GeoDB.Country(parsedIP)` which works with the interface.
  </action>
  <verify>
    Run `go build ./services/analytics-consumer/...` — must compile without errors.
    Run existing tests: `go test ./services/analytics-consumer/internal/mqs/...` — all existing tests must pass (no behavior change).
  </verify>
  <done>GeoIPReader interface defined in servicecontext.go. GeoDB field type changed to GeoIPReader. NewServiceContext uses interface-typed local variable to avoid typed-nil pitfall. All existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add resolveCountry GeoDB tests and Mobile UA test</name>
  <files>services/analytics-consumer/internal/mqs/clickeventconsumer_test.go</files>
  <action>
    Add 5 new tests to clickeventconsumer_test.go to cover the previously untested GeoDB paths in resolveCountry and the Mobile branch in resolveDeviceType:

    1. Add required imports at the top: `"net"`, `"github.com/oschwald/geoip2-golang"`, and `"go-shortener/services/analytics-consumer/internal/svc"` (svc is already imported).

    2. Define a mock GeoIPReader struct (local to the test file):
       ```go
       // mockGeoIPReader implements svc.GeoIPReader for testing.
       type mockGeoIPReader struct {
           countryFunc func(ip net.IP) (*geoip2.Country, error)
       }

       func (m *mockGeoIPReader) Country(ip net.IP) (*geoip2.Country, error) {
           return m.countryFunc(ip)
       }
       ```

    3. Add test: `TestResolveCountry_WithGeoDB_Success` — covers lines 91-106 happy path:
       ```go
       func TestResolveCountry_WithGeoDB_Success(t *testing.T) {
           mock := &mockGeoIPReader{
               countryFunc: func(ip net.IP) (*geoip2.Country, error) {
                   c := &geoip2.Country{}
                   c.Country.IsoCode = "US"
                   return c, nil
               },
           }
           svcCtx := &svc.ServiceContext{GeoDB: mock}
           result := resolveCountry(svcCtx, "8.8.8.8")
           assert.Equal(t, "US", result)
       }
       ```
       Note: Use `c := &geoip2.Country{}; c.Country.IsoCode = "US"` because geoip2.Country has anonymous nested structs that cannot be initialized with struct literal syntax.

    4. Add test: `TestResolveCountry_WithGeoDB_LookupError` — covers Country() error path:
       ```go
       func TestResolveCountry_WithGeoDB_LookupError(t *testing.T) {
           mock := &mockGeoIPReader{
               countryFunc: func(ip net.IP) (*geoip2.Country, error) {
                   return nil, errors.New("lookup failed")
               },
           }
           svcCtx := &svc.ServiceContext{GeoDB: mock}
           result := resolveCountry(svcCtx, "8.8.8.8")
           assert.Equal(t, "XX", result)
       }
       ```

    5. Add test: `TestResolveCountry_WithGeoDB_EmptyIsoCode` — covers empty IsoCode fallback:
       ```go
       func TestResolveCountry_WithGeoDB_EmptyIsoCode(t *testing.T) {
           mock := &mockGeoIPReader{
               countryFunc: func(ip net.IP) (*geoip2.Country, error) {
                   return &geoip2.Country{}, nil
               },
           }
           svcCtx := &svc.ServiceContext{GeoDB: mock}
           result := resolveCountry(svcCtx, "8.8.8.8")
           assert.Equal(t, "XX", result)
       }
       ```

    6. Add test: `TestResolveCountry_WithGeoDB_InvalidIP` — covers parsedIP == nil path when GeoDB is non-nil:
       ```go
       func TestResolveCountry_WithGeoDB_InvalidIP(t *testing.T) {
           mock := &mockGeoIPReader{
               countryFunc: func(ip net.IP) (*geoip2.Country, error) {
                   t.Fatal("Country should not be called for invalid IP")
                   return nil, nil
               },
           }
           svcCtx := &svc.ServiceContext{GeoDB: mock}
           result := resolveCountry(svcCtx, "not-an-ip")
           assert.Equal(t, "XX", result)
       }
       ```

    7. Add test: `TestResolveDeviceType_Mobile` — covers Mobile branch (line 121-123):
       ```go
       func TestResolveDeviceType_Mobile(t *testing.T) {
           // UA must contain "Mobile" token for mssola/useragent to detect it
           result := resolveDeviceType("Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.86 Mobile Safari/537.36")
           assert.Equal(t, "Mobile", result)
       }
       ```
       NOTE: The UA string MUST contain "Mobile" — the existing Android test uses a UA without "Mobile" and correctly expects "Desktop".

    Ensure `errors` is in the import block (it is already imported).
    Ensure `net` is added to the import block.
    Ensure `"github.com/oschwald/geoip2-golang"` is added to the import block.
  </action>
  <verify>
    Run `go test -v ./services/analytics-consumer/internal/mqs/...` — all tests (old and new) must pass.
    Run `go test -cover ./services/analytics-consumer/internal/mqs/...` — coverage must report > 80%.
  </verify>
  <done>5 new tests added (4 GeoDB path tests + 1 Mobile UA test). All tests pass. mqs package coverage is above 80% of statements.</done>
</task>

</tasks>

<verification>
1. `go build ./services/analytics-consumer/...` compiles without errors
2. `go test -v ./services/analytics-consumer/internal/mqs/...` — all tests pass
3. `go test -cover ./services/analytics-consumer/internal/mqs/...` — reports coverage > 80%
4. GeoIPReader interface exists in servicecontext.go and is used by GeoDB field
</verification>

<success_criteria>
- GeoIPReader interface is defined in servicecontext.go
- GeoDB field uses the interface type (not concrete *geoip2.Reader)
- 5 new tests cover GeoDB country resolution paths and Mobile UA detection
- analytics-consumer mqs package test coverage exceeds 80%
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-tech-debt-cleanup/12-02-SUMMARY.md`
</output>
