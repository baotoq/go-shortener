---
phase: 02-event-driven-analytics
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - db/analytics_schema.sql
  - db/analytics_query.sql
  - sqlc.yaml
  - internal/analytics/repository/sqlite/sqlc/db.go
  - internal/analytics/repository/sqlite/sqlc/models.go
  - internal/analytics/repository/sqlite/sqlc/querier.go
  - internal/analytics/repository/sqlite/sqlc/query.sql.go
  - internal/analytics/repository/sqlite/click_repository.go
  - internal/analytics/database/database.go
  - internal/analytics/database/migrations/000001_create_clicks.up.sql
  - internal/analytics/database/migrations/000001_create_clicks.down.sql
  - internal/analytics/usecase/click_repository.go
  - internal/analytics/usecase/analytics_service.go
  - internal/analytics/delivery/http/handler.go
  - internal/analytics/delivery/http/response.go
  - internal/analytics/delivery/http/router.go
  - cmd/analytics-service/main.go
autonomous: true

must_haves:
  truths:
    - "Analytics Service receives click events via Dapr pub/sub and stores them as individual rows"
    - "User can query total click count for any short link via GET /analytics/{code}"
    - "Zero clicks returns 200 with total_clicks: 0, not 404"
    - "Analytics Service has its own HTTP server on port 8081"
    - "Analytics Service uses its own SQLite database (analytics.db), separate from URL Service"
  artifacts:
    - path: "internal/analytics/repository/sqlite/click_repository.go"
      provides: "ClickRepository with InsertClick and CountByShortCode methods"
    - path: "internal/analytics/usecase/analytics_service.go"
      provides: "AnalyticsService with RecordClick and GetClickCount methods"
    - path: "internal/analytics/delivery/http/handler.go"
      provides: "HTTP handler for GET /analytics/{code} and Dapr event handler"
    - path: "cmd/analytics-service/main.go"
      provides: "Analytics Service entry point with Dapr subscription and Chi router"
    - path: "internal/analytics/database/migrations/000001_create_clicks.up.sql"
      provides: "Clicks table schema with indexes"
      contains: "CREATE TABLE"
    - path: "internal/analytics/usecase/click_repository.go"
      provides: "ClickRepository interface (dependency inversion)"
      exports: ["ClickRepository"]
  key_links:
    - from: "cmd/analytics-service/main.go"
      to: "internal/analytics/"
      via: "import paths"
      pattern: "go-shortener/internal/analytics"
    - from: "internal/analytics/delivery/http/handler.go"
      to: "internal/analytics/usecase/analytics_service.go"
      via: "method call"
      pattern: "analyticsService\\.RecordClick|analyticsService\\.GetClickCount"
    - from: "internal/analytics/delivery/http/handler.go"
      to: "internal/shared/events/click_event.go"
      via: "import for event deserialization"
      pattern: "go-shortener/internal/shared/events"
    - from: "internal/analytics/usecase/analytics_service.go"
      to: "internal/analytics/usecase/click_repository.go"
      via: "interface dependency"
      pattern: "ClickRepository"
---

<objective>
Build the complete Analytics Service: database schema, repository, business logic, HTTP handler, Dapr subscription, and entry point.

Purpose: The Analytics Service is a new microservice that receives click events from URL Service via Dapr pub/sub, stores individual click records in its own SQLite database, and exposes an API endpoint to query click counts. This completes the event-driven analytics pipeline.

Output: A fully functional Analytics Service binary that subscribes to click events, persists them, and serves click count queries.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-event-driven-analytics/02-CONTEXT.md
@.planning/phases/02-event-driven-analytics/02-RESEARCH.md
@.planning/phases/02-event-driven-analytics/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analytics Service schema, sqlc generation, repository, and database layer</name>
  <files>
    db/analytics_schema.sql
    db/analytics_query.sql
    sqlc.yaml
    internal/analytics/repository/sqlite/sqlc/db.go
    internal/analytics/repository/sqlite/sqlc/models.go
    internal/analytics/repository/sqlite/sqlc/querier.go
    internal/analytics/repository/sqlite/sqlc/query.sql.go
    internal/analytics/repository/sqlite/click_repository.go
    internal/analytics/database/database.go
    internal/analytics/database/migrations/000001_create_clicks.up.sql
    internal/analytics/database/migrations/000001_create_clicks.down.sql
    internal/analytics/usecase/click_repository.go
  </files>
  <action>
    Create the data layer for Analytics Service, mirroring URL Service patterns.

    **1. Create migration file `internal/analytics/database/migrations/000001_create_clicks.up.sql`:**
    ```sql
    CREATE TABLE IF NOT EXISTS clicks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        short_code TEXT NOT NULL,
        clicked_at INTEGER NOT NULL
    );

    CREATE INDEX idx_clicks_short_code ON clicks(short_code);
    CREATE INDEX idx_clicks_clicked_at ON clicks(clicked_at);
    ```
    Per user decision: individual click records (one row per click), not just counters.
    Per research: INTEGER Unix timestamps (efficient for analytics), indexes on short_code for fast COUNT and clicked_at for future time-range queries (Phase 3).
    NOTE: No FOREIGN KEY to urls table — separate databases, Analytics trusts events from URL Service (per research recommendation).

    **2. Create down migration `internal/analytics/database/migrations/000001_create_clicks.down.sql`:**
    ```sql
    DROP INDEX IF EXISTS idx_clicks_clicked_at;
    DROP INDEX IF EXISTS idx_clicks_short_code;
    DROP TABLE IF EXISTS clicks;
    ```

    **3. Create `internal/analytics/database/database.go`:**
    Mirror the URL Service database.go pattern exactly — same OpenDB function with WAL mode, same RunMigrations with embedded FS. The embed directive should reference `migrations/*.sql` within this package's directory.

    **4. Create `db/analytics_schema.sql`** for sqlc:
    ```sql
    CREATE TABLE clicks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        short_code TEXT NOT NULL,
        clicked_at INTEGER NOT NULL
    );
    ```

    **5. Create `db/analytics_query.sql`** for sqlc:
    ```sql
    -- name: InsertClick :exec
    INSERT INTO clicks (short_code, clicked_at)
    VALUES (?, ?);

    -- name: CountClicksByShortCode :one
    SELECT COUNT(*) as total_clicks FROM clicks WHERE short_code = ?;
    ```
    Use `:exec` for InsertClick (no return needed) and `:one` for count query.

    **6. Update `sqlc.yaml`** to add a second SQL configuration block for analytics:
    ```yaml
    version: "2"
    sql:
      - engine: "sqlite"
        queries: "db/query.sql"
        schema: "db/schema.sql"
        gen:
          go:
            package: "sqlc"
            out: "internal/urlservice/repository/sqlite/sqlc"
            emit_json_tags: true
            emit_interface: true
      - engine: "sqlite"
        queries: "db/analytics_query.sql"
        schema: "db/analytics_schema.sql"
        gen:
          go:
            package: "sqlc"
            out: "internal/analytics/repository/sqlite/sqlc"
            emit_json_tags: true
            emit_interface: true
    ```
    NOTE: The first entry should already point to `internal/urlservice/repository/sqlite/sqlc` from Plan 01.

    **7. Run sqlc generate:**
    ```bash
    sqlc generate
    ```
    This will generate the Go code in `internal/analytics/repository/sqlite/sqlc/`.

    **8. Create `internal/analytics/usecase/click_repository.go`** — repository interface (dependency inversion, mirroring URL Service pattern):
    ```go
    package usecase

    import "context"

    type ClickRepository interface {
        InsertClick(ctx context.Context, shortCode string, clickedAt int64) error
        CountByShortCode(ctx context.Context, shortCode string) (int64, error)
    }
    ```

    **9. Create `internal/analytics/repository/sqlite/click_repository.go`:**
    Implement ClickRepository using sqlc-generated queries. Constructor takes `*sql.DB`, creates sqlc.Queries internally. InsertClick calls generated InsertClick. CountByShortCode calls generated CountClicksByShortCode.

    Include compile-time interface check: `var _ usecase.ClickRepository = (*ClickRepository)(nil)`
  </action>
  <verify>
    Run `sqlc generate` — must succeed.
    Run `go build ./internal/analytics/...` — must compile.
    Run `go vet ./internal/analytics/...` — must pass.
    Verify generated files exist in `internal/analytics/repository/sqlite/sqlc/`.
  </verify>
  <done>Analytics data layer complete: migrations, sqlc queries, repository interface, SQLite implementation. Follows same patterns as URL Service (dependency inversion, sqlc, embedded migrations).</done>
</task>

<task type="auto">
  <name>Task 2: Analytics Service usecase, HTTP handler, Dapr subscription, and main.go entry point</name>
  <files>
    internal/analytics/usecase/analytics_service.go
    internal/analytics/delivery/http/handler.go
    internal/analytics/delivery/http/response.go
    internal/analytics/delivery/http/router.go
    cmd/analytics-service/main.go
  </files>
  <action>
    Build the business logic, HTTP delivery, and entry point for Analytics Service.

    **1. Create `internal/analytics/usecase/analytics_service.go`:**
    ```go
    package usecase

    import (
        "context"
        "go-shortener/internal/shared/events"
    )

    type AnalyticsService struct {
        repo ClickRepository
    }

    func NewAnalyticsService(repo ClickRepository) *AnalyticsService {
        return &AnalyticsService{repo: repo}
    }

    // RecordClick stores a click event
    func (s *AnalyticsService) RecordClick(ctx context.Context, event events.ClickEvent) error {
        return s.repo.InsertClick(ctx, event.ShortCode, event.Timestamp.Unix())
    }

    // GetClickCount returns total clicks for a short code
    func (s *AnalyticsService) GetClickCount(ctx context.Context, shortCode string) (int64, error) {
        return s.repo.CountByShortCode(ctx, shortCode)
    }
    ```

    **2. Create `internal/analytics/delivery/http/response.go`:**
    Mirror URL Service response helpers (writeJSON and writeProblem using `pkg/problemdetails`).

    **3. Create `internal/analytics/delivery/http/handler.go`:**

    The handler serves TWO purposes:
    a) HTTP API: `GET /analytics/{code}` — returns click count
    b) Dapr event handler: receives click events from pub/sub

    ```go
    package http

    import (
        "context"
        "encoding/json"
        "net/http"

        "go-shortener/internal/analytics/usecase"
        "go-shortener/internal/shared/events"
        "go-shortener/pkg/problemdetails"

        "github.com/go-chi/chi/v5"
        "go.uber.org/zap"
    )

    type Handler struct {
        analyticsService *usecase.AnalyticsService
        logger           *zap.Logger
    }

    func NewHandler(analyticsService *usecase.AnalyticsService, logger *zap.Logger) *Handler {
        return &Handler{
            analyticsService: analyticsService,
            logger:           logger,
        }
    }

    // AnalyticsResponse is the API response for click count queries.
    type AnalyticsResponse struct {
        ShortCode   string `json:"short_code"`
        TotalClicks int64  `json:"total_clicks"`
    }

    // GetClickCount handles GET /analytics/{code}
    func (h *Handler) GetClickCount(w http.ResponseWriter, r *http.Request) {
        code := chi.URLParam(r, "code")

        count, err := h.analyticsService.GetClickCount(r.Context(), code)
        if err != nil {
            problem := problemdetails.New(
                http.StatusInternalServerError,
                problemdetails.TypeInternalError,
                "Internal Server Error",
                "Failed to retrieve click count",
            )
            writeProblem(w, problem)
            return
        }

        // Per user decision: zero clicks returns 200 with total_clicks: 0, NOT 404
        resp := AnalyticsResponse{
            ShortCode:   code,
            TotalClicks: count,
        }
        writeJSON(w, http.StatusOK, resp)
    }

    // HandleClickEvent processes click events from Dapr pub/sub.
    // This is called by the Dapr sidecar when a message arrives on the "clicks" topic.
    // Route: POST /events/click
    func (h *Handler) HandleClickEvent(w http.ResponseWriter, r *http.Request) {
        // Dapr delivers CloudEvents — we need to extract the data field
        var cloudEvent struct {
            Data json.RawMessage `json:"data"`
        }

        if err := json.NewDecoder(r.Body).Decode(&cloudEvent); err != nil {
            h.logger.Error("failed to decode cloud event", zap.Error(err))
            // Return 200 to acknowledge — don't retry malformed events
            w.WriteHeader(http.StatusOK)
            return
        }

        var event events.ClickEvent
        if err := json.Unmarshal(cloudEvent.Data, &event); err != nil {
            h.logger.Error("failed to unmarshal click event data", zap.Error(err))
            // Return 200 to acknowledge — don't retry malformed events
            w.WriteHeader(http.StatusOK)
            return
        }

        if err := h.analyticsService.RecordClick(r.Context(), event); err != nil {
            h.logger.Error("failed to record click",
                zap.String("short_code", event.ShortCode),
                zap.Error(err),
            )
            // Per research recommendation: don't retry on Phase 2, acknowledge the event
            w.WriteHeader(http.StatusOK)
            return
        }

        h.logger.Info("click event recorded",
            zap.String("short_code", event.ShortCode),
        )

        // Return 200 to signal successful processing to Dapr
        w.WriteHeader(http.StatusOK)
    }
    ```

    NOTE on CloudEvents: Dapr wraps published data in a CloudEvents envelope. When using raw HTTP handler (not Dapr SDK service), we receive the full CloudEvent JSON. The application data is in the `data` field. We decode the outer envelope first, then unmarshal the inner data.

    **4. Create `internal/analytics/delivery/http/router.go`:**

    The router must serve:
    - `GET /analytics/{code}` — public API
    - `GET /dapr/subscribe` — programmatic subscription endpoint (per user decision)
    - `POST /events/click` — Dapr event delivery endpoint

    ```go
    package http

    import (
        "encoding/json"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"
    )

    func NewRouter(handler *Handler, logger *zap.Logger) http.Handler {
        r := chi.NewRouter()

        // Middleware
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(middleware.Recoverer)

        // Dapr subscription endpoint — tells Dapr what topics to subscribe to
        r.Get("/dapr/subscribe", func(w http.ResponseWriter, r *http.Request) {
            subscriptions := []map[string]string{
                {
                    "pubsubname": "pubsub",
                    "topic":      "clicks",
                    "route":      "/events/click",
                },
            }
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(subscriptions)
        })

        // Dapr event delivery endpoint
        r.Post("/events/click", handler.HandleClickEvent)

        // Analytics API
        r.Get("/analytics/{code}", handler.GetClickCount)

        return r
    }
    ```

    **5. Create `cmd/analytics-service/main.go`:**

    Wire everything together, mirroring URL Service main.go patterns:
    - Initialize Zap logger
    - Read config from env vars: PORT (default 8081), DATABASE_PATH (default data/analytics.db)
    - Create data directory, open SQLite DB, run migrations
    - Wire: ClickRepository -> AnalyticsService -> Handler -> Router
    - Start HTTP server on configured port
    - Graceful shutdown on SIGINT/SIGTERM

    ```go
    package main

    import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        analyticsdb "go-shortener/internal/analytics/database"
        analyticshttp "go-shortener/internal/analytics/delivery/http"
        analyticssqlite "go-shortener/internal/analytics/repository/sqlite"
        "go-shortener/internal/analytics/usecase"

        _ "modernc.org/sqlite"
        "go.uber.org/zap"
    )

    func getEnv(key, defaultValue string) string {
        if value := os.Getenv(key); value != "" {
            return value
        }
        return defaultValue
    }

    func main() {
        logger, err := zap.NewDevelopment()
        if err != nil {
            panic("failed to initialize logger: " + err.Error())
        }
        defer logger.Sync()

        port := getEnv("PORT", "8081")
        databasePath := getEnv("DATABASE_PATH", "data/analytics.db")

        // Ensure data directory exists
        if err := os.MkdirAll(filepath.Dir(databasePath), 0755); err != nil {
            logger.Fatal("failed to create data directory", zap.Error(err))
        }

        // Open database (separate from URL Service)
        db, err := analyticsdb.OpenDB(databasePath)
        if err != nil {
            logger.Fatal("failed to open database", zap.Error(err))
        }
        defer db.Close()

        // Run analytics migrations
        if err := analyticsdb.RunMigrations(db); err != nil {
            logger.Fatal("failed to run migrations", zap.Error(err))
        }

        logger.Info("analytics database initialized", zap.String("path", databasePath))

        // Wire dependencies
        repo := analyticssqlite.NewClickRepository(db)
        service := usecase.NewAnalyticsService(repo)
        handler := analyticshttp.NewHandler(service, logger)
        router := analyticshttp.NewRouter(handler, logger)

        // Create HTTP server
        srv := &http.Server{
            Addr:    ":" + port,
            Handler: router,
        }

        // Start server
        go func() {
            logger.Info("analytics service starting", zap.String("port", port))
            if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
                logger.Fatal("server failed", zap.Error(err))
            }
        }()

        // Graceful shutdown
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        <-quit

        logger.Info("analytics service shutting down")
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil {
            logger.Fatal("server forced to shutdown", zap.Error(err))
        }

        logger.Info("analytics service stopped")
    }
    ```

    Per user decision: Analytics Service has its own HTTP server, separate port (8081 default), separate SQLite database (analytics.db). NOT proxied through URL Service.
  </action>
  <verify>
    Run `go build ./cmd/analytics-service/` — must compile successfully.
    Run `go build ./cmd/url-service/` — must still compile (no regressions).
    Run `go vet ./...` — must pass.
    Verify `cmd/analytics-service/main.go` exists and builds a binary.
    Verify handler.go contains both `GetClickCount` and `HandleClickEvent` methods.
  </verify>
  <done>
    Complete Analytics Service with:
    - Schema with clicks table and indexes
    - sqlc-generated repository code
    - ClickRepository interface (dependency inversion)
    - AnalyticsService with RecordClick and GetClickCount
    - HTTP handler for GET /analytics/{code} (returns 200 with total_clicks, even for zero)
    - Dapr subscription endpoint and event handler
    - Standalone main.go with its own HTTP server, database, and graceful shutdown
    Both cmd/url-service and cmd/analytics-service compile successfully.
  </done>
</task>

</tasks>

<verification>
1. `go build ./cmd/analytics-service/` compiles successfully
2. `go build ./cmd/url-service/` still compiles (no regressions)
3. `go vet ./...` passes
4. Analytics Service has `/dapr/subscribe` endpoint returning subscription for "clicks" topic
5. Analytics Service has `POST /events/click` handler for Dapr event delivery
6. Analytics Service has `GET /analytics/{code}` returning `{"short_code": "...", "total_clicks": N}`
7. Zero clicks returns 200 with `total_clicks: 0`, not 404
8. Analytics uses separate database (analytics.db), not URL Service's shortener.db
9. Clean architecture: handler -> usecase -> repository with interface
10. sqlc generates valid code for analytics queries
</verification>

<success_criteria>
- Both services compile: `go build ./cmd/url-service/` and `go build ./cmd/analytics-service/`
- Analytics Service mirrors URL Service clean architecture patterns
- Dapr subscription correctly registered for "clicks" topic
- Click events stored as individual rows (not aggregated counters)
- Analytics API returns correct response format per user decision
- Separate SQLite database for data isolation
</success_criteria>

<output>
After completion, create `.planning/phases/02-event-driven-analytics/02-03-SUMMARY.md`
</output>
