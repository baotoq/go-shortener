---
phase: 11-ci-pipeline-docker-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - .golangci.yml
  - .coverage.yaml
  - test/integration/shorten_test.go
  - test/integration/redirect_test.go
autonomous: true

must_haves:
  truths:
    - "CI pipeline runs on every push to any branch AND on pull requests to master"
    - "golangci-lint v2 lints the v2.0 codebase without errors in CI"
    - "Unit tests pass in CI with race detection enabled"
    - "Integration tests using testcontainers-go run real PostgreSQL in CI"
    - "All three services build successfully in CI (compilation verified)"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Updated CI workflow for v2.0 go-zero structure"
      contains: "services"
    - path: ".golangci.yml"
      provides: "golangci-lint v2 configuration for go-zero project"
      contains: "version"
    - path: ".coverage.yaml"
      provides: "Updated coverage paths for v2.0 services/ structure"
      contains: "services"
    - path: "test/integration/shorten_test.go"
      provides: "Integration test for URL shortening with real PostgreSQL"
      contains: "testcontainers"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: ".golangci.yml"
      via: "golangci-lint reads config file"
      pattern: "golangci-lint"
    - from: ".github/workflows/ci.yml"
      to: "test/integration/"
      via: "go test with integration build tag"
      pattern: "integration"
    - from: "test/integration/"
      to: "services/"
      via: "testcontainers spinning up PostgreSQL and testing service logic"
      pattern: "testcontainers"
---

<objective>
Update the GitHub Actions CI pipeline for the v2.0 go-zero project structure, update linting/coverage configs, and add integration tests using testcontainers-go.

Purpose: The existing CI workflow targets the v1.0 structure (cmd/url-service, cmd/analytics-service, separate Dockerfiles). It needs complete rewrite for v2.0 (services/url-api, services/analytics-rpc, services/analytics-consumer, single Dockerfile). Integration tests with testcontainers provide confidence that services work with real PostgreSQL and Kafka.

Output: Working CI pipeline that lints, tests (unit + integration), and builds all v2.0 services on every push.
</objective>

<execution_context>
@/Users/baotoq/.claude/get-shit-done/workflows/execute-plan.md
@/Users/baotoq/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.github/workflows/ci.yml
@.golangci.yml
@.coverage.yaml
@go.mod
@Dockerfile
@services/url-api/url.go
@services/analytics-rpc/analytics.go
@services/analytics-consumer/consumer.go
@services/url-api/model/urlsmodel.go
@services/url-api/model/urlsmodel_gen.go
@services/analytics-rpc/model/clicksmodel.go
@services/analytics-rpc/model/clicksmodel_gen.go
@services/migrations/000001_create_urls.up.sql
@services/migrations/000002_create_clicks.up.sql
@services/migrations/000003_add_clicks_enrichment.up.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CI workflow, golangci-lint config, and coverage config for v2.0</name>
  <files>
    .github/workflows/ci.yml
    .golangci.yml
    .coverage.yaml
  </files>
  <action>
    **1. Update `.golangci.yml` for v2 format and v2.0 paths:**

    The current `.golangci.yml` uses v1 format and references v1.0 paths (`internal/urlservice/`, `internal/analytics/`). Update to golangci-lint v2 format:

    ```yaml
    version: "2"

    run:
      timeout: 5m
      tests: true

    linters:
      enable:
        - errcheck
        - gosimple
        - govet
        - ineffassign
        - staticcheck
        - unused
        - misspell
        - revive
        - goconst
        - unparam
      disable:
        - gocyclo  # Disabled: go-zero generated code has high cyclomatic complexity

    linters-settings:
      goconst:
        min-len: 3
        min-occurrences: 3

    formatters:
      enable:
        - gofmt
        - goimports

    issues:
      exclude-dirs:
        - services/analytics-rpc/analytics  # Generated protobuf code
      exclude-files:
        - ".*_gen\\.go$"  # goctl-generated model files
      exclude-rules:
        - path: _test\.go
          linters:
            - errcheck
    ```

    Key changes from v1:
    - Add `version: "2"` at top (required for golangci-lint v2)
    - Update `exclude-dirs` from v1.0 paths to v2.0 paths (protobuf generated code)
    - Add `exclude-files` pattern for `*_gen.go` files (goctl-generated, no point linting)
    - Add `formatters` section for `gofmt` and `goimports` (v2 feature, replaces linter-based formatting)
    - Remove `gocyclo` (go-zero generated code has high complexity, produces noise)

    **2. Update `.coverage.yaml` for v2.0 paths:**

    ```yaml
    threshold:
      total: 70
      package: 50

    override:
      - path: "go-shortener/services/analytics-rpc/analytics"
        threshold: 0  # Generated protobuf code
      - path: "go-shortener/services/url-api/internal/handler"
        threshold: 0  # Generated handler code
      - path: "go-shortener/services/url-api/internal/types"
        threshold: 0  # Generated types
      - path: "go-shortener/services/analytics-rpc/internal/server"
        threshold: 0  # Generated server code
      - path: "go-shortener/pkg"
        threshold: 50  # Shared packages
    ```

    Lower total threshold from 80 to 70 because go-zero generates significant uncovered code (handlers, types, server stubs). The logic packages maintain 76%+ coverage from Phase 10.

    **3. Rewrite `.github/workflows/ci.yml` for v2.0:**

    ```yaml
    name: CI

    on:
      push:
        branches: ['**']  # Every push to any branch
      pull_request:
        branches: [master]

    jobs:
      lint:
        name: Lint
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v4
          - uses: actions/setup-go@v5
            with:
              go-version-file: go.mod
              cache: true
          - name: Install golangci-lint
            run: go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest
          - name: Run golangci-lint
            run: golangci-lint run --timeout 5m

      test:
        name: Unit Test
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v4
          - uses: actions/setup-go@v5
            with:
              go-version-file: go.mod
              cache: true
          - name: Run unit tests with coverage
            run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./services/...
          - name: Upload coverage artifact
            uses: actions/upload-artifact@v4
            with:
              name: coverage-report
              path: coverage.out
              retention-days: 7

      integration-test:
        name: Integration Test
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v4
          - uses: actions/setup-go@v5
            with:
              go-version-file: go.mod
              cache: true
          - name: Run integration tests
            run: go test -v -tags integration -timeout 10m -count=1 ./test/integration/...

      build:
        name: Build
        runs-on: ubuntu-latest
        needs: [lint, test, integration-test]
        strategy:
          matrix:
            service: [url-api, analytics-rpc, analytics-consumer]
        steps:
          - uses: actions/checkout@v4
          - uses: actions/setup-go@v5
            with:
              go-version-file: go.mod
              cache: true
          - name: Build ${{ matrix.service }}
            run: |
              CGO_ENABLED=0 go build -ldflags="-s -w" \
                -o bin/${{ matrix.service }} \
                ./services/${{ matrix.service }}/
    ```

    Key changes from v1.0 CI:
    - `push.branches: ['**']` triggers on all branches (per user decision), not just main/master
    - `go-version-file: go.mod` replaces hardcoded `go-version: '1.24'` (future-proof)
    - Unit tests target `./services/...` not `./...` (avoids running integration tests)
    - Build uses matrix strategy for 3 v2.0 services (not v1.0 cmd/ paths)
    - Removed Docker image builds from CI (not needed for this phase)
    - Removed go-test-coverage enforcement (threshold too strict for generated code)
    - Added integration-test job with `--tags integration` and testcontainers
    - Build depends on all three test/lint jobs
  </action>
  <verify>
    Verify the YAML files are valid: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml')); print('ci.yml OK')"` (or equivalent).
    Run `go build ./services/url-api/ && go build ./services/analytics-rpc/ && go build ./services/analytics-consumer/` to verify the build commands work.
    Run `golangci-lint run --timeout 5m` locally to verify lint passes with new config (install golangci-lint v2 if needed: `go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest`).
  </verify>
  <done>
    CI workflow triggers on all pushes and PRs to master. Lint job uses golangci-lint v2 with updated config. Unit test job runs with race detection on services/. Integration test job runs testcontainers tests. Build job compiles all 3 v2.0 services via matrix. All configs target v2.0 paths.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add testcontainers-go integration tests for URL shortening and redirect</name>
  <files>
    test/integration/shorten_test.go
    test/integration/redirect_test.go
  </files>
  <action>
    **1. Install testcontainers dependencies:**

    ```bash
    go get github.com/testcontainers/testcontainers-go
    go get github.com/testcontainers/testcontainers-go/modules/postgres
    go get github.com/jackc/pgx/v5/stdlib
    ```

    Note: Kafka testcontainer is deferred -- testing PostgreSQL operations first is higher value. The Kafka publishing flow was already verified in 11-02. Integration tests here focus on the core database operations.

    **2. Create `test/integration/` directory structure.**

    **3. Create `test/integration/shorten_test.go`:**

    Use `//go:build integration` build tag at the top of the file.

    This test verifies the full shorten flow against a real PostgreSQL:
    - Start a PostgreSQL testcontainer with the project's migration scripts applied
    - Create a `sqlx.SqlConn` using the testcontainer's connection string
    - Instantiate the real `model.NewUrlsModel(conn)`
    - Call model methods directly (Insert, FindOneByShortCode, FindOne) to verify DB operations

    ```go
    //go:build integration

    package integration_test

    import (
        "context"
        "testing"

        "github.com/google/uuid"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
        "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/zeromicro/go-zero/core/stores/sqlx"
        _ "github.com/lib/pq"

        urlModel "go-shortener/services/url-api/model"
    )

    func setupPostgres(t *testing.T) (sqlx.SqlConn, func()) {
        ctx := context.Background()

        container, err := postgres.Run(ctx,
            "postgres:16-alpine",
            postgres.WithDatabase("shortener"),
            postgres.WithUsername("postgres"),
            postgres.WithPassword("postgres"),
            postgres.WithInitScripts(
                "../../services/migrations/000001_create_urls.up.sql",
                "../../services/migrations/000002_create_clicks.up.sql",
                "../../services/migrations/000003_add_clicks_enrichment.up.sql",
            ),
            postgres.BasicWaitStrategies(),
            postgres.WithSQLDriver("pgx"),
        )
        require.NoError(t, err)

        connStr, err := container.ConnectionString(ctx, "sslmode=disable")
        require.NoError(t, err)

        conn := sqlx.NewSqlConn("pgx", connStr)

        cleanup := func() {
            container.Terminate(ctx)
        }

        return conn, cleanup
    }

    func TestShortenIntegration(t *testing.T) {
        conn, cleanup := setupPostgres(t)
        defer cleanup()

        model := urlModel.NewUrlsModel(conn)
        ctx := context.Background()

        // Test: Insert a new URL
        id := uuid.Must(uuid.NewV7())
        _, err := model.Insert(ctx, &urlModel.Urls{
            Id:          id.String(),
            ShortCode:   "testcode",
            OriginalUrl: "https://example.com/integration-test",
        })
        require.NoError(t, err)

        // Test: Find by short code
        found, err := model.FindOneByShortCode(ctx, "testcode")
        require.NoError(t, err)
        assert.Equal(t, "https://example.com/integration-test", found.OriginalUrl)
        assert.Equal(t, "testcode", found.ShortCode)

        // Test: Find by ID
        foundById, err := model.FindOne(ctx, id.String())
        require.NoError(t, err)
        assert.Equal(t, "testcode", foundById.ShortCode)

        // Test: Increment click count
        err = model.IncrementClickCount(ctx, "testcode")
        require.NoError(t, err)

        updated, err := model.FindOneByShortCode(ctx, "testcode")
        require.NoError(t, err)
        assert.Equal(t, int64(1), updated.ClickCount)
    }
    ```

    **4. Create `test/integration/redirect_test.go`:**

    Use `//go:build integration` build tag.

    This test verifies the click model operations against real PostgreSQL:

    ```go
    //go:build integration

    package integration_test

    import (
        "context"
        "testing"
        "time"

        "github.com/google/uuid"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"

        clicksModel "go-shortener/services/analytics-rpc/model"
    )

    func TestClicksIntegration(t *testing.T) {
        conn, cleanup := setupPostgres(t)
        defer cleanup()

        model := clicksModel.NewClicksModel(conn)
        ctx := context.Background()

        // Test: Insert a click record
        clickId := uuid.Must(uuid.NewV7())
        _, err := model.Insert(ctx, &clicksModel.Clicks{
            Id:            clickId.String(),
            ShortCode:     "testcode",
            ClickedAt:     time.Now(),
            CountryCode:   "US",
            DeviceType:    "Desktop",
            TrafficSource: "Direct",
        })
        require.NoError(t, err)

        // Test: Count by short code
        count, err := model.CountByShortCode(ctx, "testcode")
        require.NoError(t, err)
        assert.Equal(t, int64(1), count)

        // Test: Insert another click for same short code
        clickId2 := uuid.Must(uuid.NewV7())
        _, err = model.Insert(ctx, &clicksModel.Clicks{
            Id:            clickId2.String(),
            ShortCode:     "testcode",
            ClickedAt:     time.Now(),
            CountryCode:   "GB",
            DeviceType:    "Mobile",
            TrafficSource: "Social",
        })
        require.NoError(t, err)

        count, err = model.CountByShortCode(ctx, "testcode")
        require.NoError(t, err)
        assert.Equal(t, int64(2), count)

        // Test: Count for non-existent short code returns 0
        count, err = model.CountByShortCode(ctx, "nonexistent")
        require.NoError(t, err)
        assert.Equal(t, int64(0), count)
    }
    ```

    **Important notes:**
    - Use `//go:build integration` tag so these tests ONLY run when `-tags integration` is passed
    - Normal `go test ./...` will NOT run these tests (CI unit test job is unaffected)
    - The `setupPostgres` helper function is shared between test files in the same package
    - Migration scripts are referenced via relative path from test/integration/ to services/migrations/
    - The `pgx` driver is used for testcontainers compatibility (`postgres.WithSQLDriver("pgx")`)
    - The `lib/pq` driver import is kept for sqlx compatibility (go-zero's sqlx uses lib/pq)
    - Container cleanup via `defer cleanup()` ensures no orphaned containers
    - Each test function creates its own data, no shared state between tests

    **5. Run `go mod tidy`** to clean up dependencies after adding testcontainers.

    **6. Verify integration tests pass locally:**
    ```bash
    go test -v -tags integration -timeout 10m -count=1 ./test/integration/...
    ```

    Note: This requires Docker to be running locally. The tests will pull postgres:16-alpine image if not cached.

    **Adapt to actual model interfaces:** Read the actual model files (urlsmodel.go, urlsmodel_gen.go, clicksmodel.go, clicksmodel_gen.go) to ensure the test calls match actual method signatures. The test code above is based on the expected interfaces from Phase 8 -- verify and adjust field names, method signatures, and types as needed.
  </action>
  <verify>
    Run `go test -v -tags integration -timeout 10m -count=1 ./test/integration/...` to verify integration tests pass with real PostgreSQL testcontainer.
    Run `go test ./services/...` to verify unit tests still pass (integration tests excluded by build tag).
    Run `go vet ./...` to verify no obvious issues.
  </verify>
  <done>
    Integration tests exist in test/integration/ with `//go:build integration` tag. Tests use testcontainers-go to spin up real PostgreSQL, apply migrations, and verify model operations (insert, find, count). Tests pass locally with Docker and will pass in CI via the integration-test job.
  </done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` has lint, test, integration-test, and build jobs targeting v2.0 structure
2. `.golangci.yml` uses v2 format with `version: "2"` and excludes generated code
3. `.coverage.yaml` references v2.0 `services/` paths
4. `test/integration/shorten_test.go` uses testcontainers-go PostgreSQL module
5. `test/integration/redirect_test.go` tests click model operations with real DB
6. `go test ./services/...` (unit tests) pass
7. `go test -v -tags integration -timeout 10m ./test/integration/...` (integration tests) pass locally
8. golangci-lint runs without errors on v2.0 codebase
</verification>

<success_criteria>
- CI workflow triggers on all pushes (any branch) and PRs to master
- golangci-lint v2 passes on v2.0 codebase with generated code excluded
- Unit tests run with race detection in CI
- Integration tests spin up real PostgreSQL via testcontainers and pass
- All three services compile successfully via matrix build
</success_criteria>

<output>
After completion, create `.planning/phases/11-ci-pipeline-docker-hardening/11-03-SUMMARY.md`
</output>
